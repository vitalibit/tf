{
  "version": 4,
  "terraform_version": "1.5.0",
  "serial": 5,
  "lineage": "925dc5a6-048d-e8e6-3505-7da42d56725a",
  "outputs": {
    "node_ip": {
      "value": [
        "34.136.14.165",
        "34.133.32.21"
      ],
      "type": [
        "tuple",
        [
          "string",
          "string"
        ]
      ]
    }
  },
  "resources": [
    {
      "mode": "data",
      "type": "google_compute_instance",
      "name": "nodes",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "index_key": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instances/gke-demo-cluster-main-fda3b6c7-2xkm",
          "schema_version": 0,
          "attributes": {
            "advanced_machine_features": null,
            "allow_stopping_for_update": null,
            "attached_disk": [],
            "boot_disk": [
              {
                "auto_delete": true,
                "device_name": "persistent-disk-0",
                "disk_encryption_key_raw": "",
                "disk_encryption_key_sha256": "",
                "initialize_params": [
                  {
                    "image": "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/images/gke-1258-gke1000-cos-101-17162-127-42-v230330-c-cgpv1-pre",
                    "labels": {
                      "goog-gke-node": "",
                      "goog-gke-volume": "",
                      "goog-k8s-cluster-location": "us-central1-c",
                      "goog-k8s-cluster-name": "demo-cluster",
                      "goog-k8s-node-pool-name": "main"
                    },
                    "size": 100,
                    "type": "pd-balanced"
                  }
                ],
                "kms_key_self_link": "",
                "mode": "READ_WRITE",
                "source": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/disks/gke-demo-cluster-main-fda3b6c7-2xkm"
              }
            ],
            "can_ip_forward": true,
            "confidential_instance_config": null,
            "cpu_platform": "Intel Haswell",
            "current_status": "RUNNING",
            "deletion_protection": false,
            "description": null,
            "desired_status": null,
            "enable_display": false,
            "guest_accelerator": [],
            "hostname": null,
            "id": "projects/k8s-k3s-386218/zones/us-central1-c/instances/gke-demo-cluster-main-fda3b6c7-2xkm",
            "instance_id": "8605729895700853086",
            "label_fingerprint": "oxbNtz4VdcY=",
            "labels": {
              "goog-gke-node": "",
              "goog-k8s-cluster-location": "us-central1-c",
              "goog-k8s-cluster-name": "demo-cluster",
              "goog-k8s-node-pool-name": "main"
            },
            "machine_type": "g1-small",
            "metadata": {
              "cluster-location": "us-central1-c",
              "cluster-name": "demo-cluster",
              "cluster-uid": "3f5a8ffbae25412187837c1f034c66c50295e3b1a4354bef868e317f6ec6a26f",
              "configure-sh": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION='v0.9.1'\nDEFAULT_CNI_HASH='b5a59660053a5f1a33b5dd5624d9ed61864482d9dc8e5b79c9b3afc3d6f62c9830e1c30f9ccba6ee76f5fb1ff0504e58984420cc0680b26cb643f1cb07afbd1c'\nDEFAULT_NPD_VERSION='v0.8.13'\nDEFAULT_NPD_HASH_AMD64='24e705d30b5839264cb64c54a19928a1a7e6fe7b8cba730f50bb737e920136f16410572f2bfe065a5f4aa1a77f9d2616d7dac37e9d4e1edd30b870c586937f65'\nDEFAULT_NPD_HASH_ARM64='f41858b118cd8c09351cc5518d554728324713b8ee77e71184ef856f89e9302560aefbc3bb9a43b37bce5cb272bc508f991c2c2e4e7e940aeac4384d8f4de5c1'\nDEFAULT_CRICTL_VERSION='v1.24.2-gke.3'\nDEFAULT_CRICTL_AMD64_SHA512='31203f35e1d857e32f55c169b7a9e9dc03009eb5b842684d948b10bc961f05970ca96673f7ef76aa73df5b1e5ec0f773812aaf49938924851c58720f6f32450f'\nDEFAULT_CRICTL_ARM64_SHA512='e4e8d80919b08e6d02905c13b92e1d1a6db78a52efdb8277f454666a7901c308667a1faf60714731f75ba48c3292d520e5277bc92877d6cb60f93cf3045f90c0'\nDEFAULT_MOUNTER_ROOTFS_VERSION='v1.0.0'\nDEFAULT_MOUNTER_ROOTFS_TAR_AMD64_SHA512='631330b7fa911d67e400b1d014df65a7763667d4afd4ecefe11a4a89dc9b8be626e5610d53b536c255a3ab488408ab2da8a0699d9fdad280cb3aa24bc2f30ab0'\nDEFAULT_MOUNTER_ROOTFS_TAR_ARM64_SHA512='83cf9ab7961627359654131abd2d4c4b72875d395c50cda9e417149b2eb53b784dfe5c2f744ddbccfe516e36dd64c716d69d161d8bc8b4f42a9207fe676d0bc1'\n###\n\n# This version needs to be the same as in gke/cluster/gce/gci/configure-helper.sh\nGKE_CONTAINERD_INFRA_CONTAINER=\"${CONTAINERD_INFRA_CONTAINER:-gke.gcr.io/pause:3.8@sha256:880e63f94b145e46f1b1082bb71b85e21f16b99b180b9996407d61240ceb9830}\"\n\nRIPTIDE_FUSE_BUCKET=\"${RIPTIDE_FUSE_BUCKET:-gke-release}\"\nRIPTIDE_SNAPSHOTTER_BUCKET=\"${RIPTIDE_SNAPSHOTTER_BUCKET:-gke-release}\"\nRIPTIDE_FUSE_VERSION=\"${RIPTIDE_FUSE_VERSION:-v0.150.0}\"\nRIPTIDE_SNAPSHOTTER_VERSION=\"${RIPTIDE_SNAPSHOTTER_VERSION:-v1.4-25}\"\n\n# Standard curl flags.\nCURL_FLAGS='--fail --silent --show-error --retry 5 --retry-delay 3 --connect-timeout 10 --retry-connrefused'\n\nfunction set-broken-motd {\n  cat \u003e /etc/motd \u003c\u003cEOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes it out.\n# Args:\n#   $1 : URL path after /computeMetadata/v1/ (without heading slash).\n#   $2 : An optional default value to echo out if the fetch fails.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction get-metadata-value {\n  local default=\"${2:-}\"\n\n  local status\n  # shellcheck disable=SC2086\n  curl ${CURL_FLAGS} \\\n    -H 'Metadata-Flavor: Google' \\\n    \"http://metadata/computeMetadata/v1/${1}\" \\\n  || status=\"$?\"\n  status=\"${status:-0}\"\n\n  if [[ \"${status}\" -eq 0 || -z \"${default}\" ]]; then\n    return \"${status}\"\n  else\n    echo \"${default}\"\n  fi\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" \u0026\u0026 $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      # shellcheck disable=SC2086\n      retry-forever 10 curl ${CURL_FLAGS} \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(python3 -c '''\nimport pipes,sys,yaml\nitems = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${kube_env_path}\" \u003e \"${KUBE_HOME}/kube-env\")\"\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    \"${kube_env_hms_path}\"\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    # shellcheck disable=SC2086\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kubelet_config}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config\n    # only write to the final location if curl succeeds\n    mv \"${tmp_kubelet_config}\" \"${dest}\"\n  )\n}\n\n# A function to pull kube-master-certs from HMS using hurl\nfunction download-kube-master-certs-hurl {\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r tmp_kube_master_certs_path=\"/tmp/kube-master-certs.yaml\"\n  local -r kube_master_certs_path=\"${KUBE_HOME}/kube-master-certs\"\n  local -r kube_master_certs_hms_path=$(get-metadata-value \"instance/attributes/kube-master-certs-path\")\n\n  echo \"Downloading kube-master-certs via hurl from ${kube_master_certs_hms_path} to ${tmp_kube_master_certs_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${tmp_kube_master_certs_path}\" \\\n    \"${kube_master_certs_hms_path}\"\n\n  # Convert the yaml format file into a shell-style file.\n  eval \"$(python3 -c '''\nimport pipes,sys,yaml\nitems = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${tmp_kube_master_certs_path}\" \u003e \"${kube_master_certs_path}\")\"\n\n  # Remove the temp certs and strip perms for other users\n  rm -f \"${tmp_kube_master_certs_path}\"\n  chmod 600 \"${kube_master_certs_path}\"\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] \u0026\u0026 [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  # shellcheck disable=SC2086\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" \\\n  | python3 -c 'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  # shellcheck disable=SC2086\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" \\\n  | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=${KUBERNETES_MASTER:-$(get-metadata-value \"instance/attributes/is-master-node\")}\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=${ENABLE_HMS_READ:-$(get-metadata-value \"instance/attributes/enable_hms_read\")}\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" \u0026\u0026 \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  while true; do\n    for url in \"$@\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers if the VM service account has storage scopes\n      local curl_headers=\"\"\n\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] ; then\n        local canUseCredentials=0\n\n        echo \"Getting the scope of service account configured for VM.\"\n        if ! valid-storage-scope ; then\n          canUseCredentials=1\n          # this behavior is preserved for backward compatibility. We want to fail fast if SA is not available\n          # and try to download without SA if scope does not exist on SA\n          echo \"No service account or service account without storage scope. Attempt to download without service account token.\"\n        fi\n\n        if [[ \"${canUseCredentials}\" == \"0\" ]] ; then\n          echo \"Getting the service account access token configured for VM.\"\n          local access_token=\"\";\n          if access_token=$(get-credentials); then\n            echo \"Service account access token is received. Downloading ${url} using this token.\"\n          else\n            echo \"Cannot get a service account token. Exiting.\"\n            exit 1\n          fi\n\n          curl_headers=${access_token:+Authorization: Bearer \"${access_token}\"}\n        fi\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --retry 6 --retry-delay 10 --retry-connrefused \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] \u0026\u0026 ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction record-preload-info {\n  echo \"$1,$2\" \u003e\u003e \"${KUBE_HOME}/preload_info\"\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo -e \"${1//,/'\\n'}\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p \"$flexvolume_plugin_dir\"\n  mount --bind \"$flexvolume_plugin_dir\" \"$flexvolume_plugin_dir\"\n  mount -o remount,exec \"$flexvolume_plugin_dir\"\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  if [[ -n \"${MOUNTER_ROOTFS_VERSION:-}\" ]]; then\n      local -r mounter_rootfs_version=\"${MOUNTER_ROOTFS_VERSION}\"\n      local -r mounter_rootfs_tar_sha=\"${MOUNTER_ROOTFS_TAR_SHA512}\"\n  else\n    local -r mounter_rootfs_version=\"${DEFAULT_MOUNTER_ROOTFS_VERSION}\"\n    case \"${HOST_PLATFORM}/${HOST_ARCH}\" in\n      linux/amd64)\n        local -r mounter_rootfs_tar_sha=\"${DEFAULT_MOUNTER_ROOTFS_TAR_AMD64_SHA512}\"\n        ;;\n      linux/arm64)\n        local -r mounter_rootfs_tar_sha=\"${DEFAULT_MOUNTER_ROOTFS_TAR_ARM64_SHA512}\"\n        ;;\n      *)\n        echo \"Unrecognized version and platform/arch combination:\"\n        echo \"$mounter_rootfs_version $HOST_PLATFORM/$HOST_ARCH\"\n        echo \"Set MOUNTER_ROOTFS_VERSION and MOUNTER_ROOTFS_TAR_SHA512 to overwrite\"\n        exit 1\n        ;;\n    esac\n  fi\n\n  if is-preloaded \"mounter\" \"${mounter_rootfs_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n\n  # Copy the mounter binary downloaded with the k8s binaries tar file\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  # Download the debian rootfs required for the mounter container\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  local -r mounter_rootfs_tar=\"containerized-mounter-${mounter_rootfs_version}_${HOST_PLATFORM}_${HOST_ARCH}.tar.gz\"\n  download-or-bust \"${mounter_rootfs_tar_sha}\" \"https://storage.googleapis.com/gke-release/containerized-mounter/${mounter_rootfs_version}/${mounter_rootfs_tar}\"\n  mv \"${KUBE_HOME}/${mounter_rootfs_tar}\" \"/tmp/${mounter_rootfs_tar}\"\n  tar xzf \"/tmp/${mounter_rootfs_tar}\" -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm \"/tmp/${mounter_rootfs_tar}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n\n  record-preload-info \"mounter\" \"${mounter_rootfs_tar_sha}\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n  if [[ -n \"${NODE_PROBLEM_DETECTOR_VERSION:-}\" ]]; then\n      local -r npd_version=\"${NODE_PROBLEM_DETECTOR_VERSION}\"\n      local -r npd_hash=\"${NODE_PROBLEM_DETECTOR_TAR_HASH}\"\n  else\n      local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n      case \"${HOST_PLATFORM}/${HOST_ARCH}\" in\n        linux/amd64)\n          local -r npd_hash=\"${DEFAULT_NPD_HASH_AMD64}\"\n          ;;\n        linux/arm64)\n          local -r npd_hash=\"${DEFAULT_NPD_HASH_ARM64}\"\n          ;;\n        # no other architectures are supported currently.\n        # Assumption is that this script only runs on linux,\n        # see cluster/gce/windows/k8s-node-setup.psm1 for windows\n        # https://github.com/kubernetes/node-problem-detector/releases/\n        *)\n          echo \"Unrecognized version and platform/arch combination:\"\n          echo \"$DEFAULT_NPD_VERSION $HOST_PLATFORM/$HOST_ARCH\"\n          echo \"Set NODE_PROBLEM_DETECTOR_VERSION and NODE_PROBLEM_DETECTOR_TAR_HASH to overwrite\"\n          exit 1\n          ;;\n      esac\n  fi\n  local -r npd_tar=\"node-problem-detector-${npd_version}-${HOST_PLATFORM}_${HOST_ARCH}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/gke-release}\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n\n  record-preload-info \"${npd_tar}\" \"${npd_hash}\"\n}\n\nfunction install-cni-binaries {\n  local -r cni_version=${CNI_VERSION:-$DEFAULT_CNI_VERSION}\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_hash=\"${CNI_HASH:-}\"\n  else\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n\n  record-preload-info \"${cni_tar}\" \"${cni_hash}\"\n}\n\n# Install crictl binary.\n# Assumptions: HOST_PLATFORM and HOST_ARCH are specified by calling detect_host_info.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    case \"${HOST_PLATFORM}/${HOST_ARCH}\" in\n      linux/amd64)\n        local -r crictl_hash=\"${DEFAULT_CRICTL_AMD64_SHA512}\"\n        ;;\n      linux/arm64)\n        local -r crictl_hash=\"${DEFAULT_CRICTL_ARM64_SHA512}\"\n        ;;\n      *)\n        echo \"Unrecognized version and platform/arch combination:\"\n        echo \"$DEFAULT_CRICTL_VERSION $HOST_PLATFORM/$HOST_ARCH\"\n        echo \"Set CRICTL_VERSION and CRICTL_TAR_HASH to overwrite\"\n        exit 1\n    esac\n  fi\n  local -r crictl=\"crictl-${crictl_version}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\"\n\n  # Create crictl config file.\n  cat \u003e /etc/crictl.yaml \u003c\u003cEOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/gke-release/cri-tools/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n  rm -f \"${crictl}\"\n\n  record-preload-info \"${crictl}\" \"${crictl_hash}\"\n}\n\nfunction preload-pause-image {\n  if is-preloaded \"pause\" \"${GKE_CONTAINERD_INFRA_CONTAINER}\"; then\n    echo \"pause image is preloaded\"\n    return\n  fi\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    # Preload with no credential when runtime is docker because docker needs\n    # special login setup.\n    docker pull ${GKE_CONTAINERD_INFRA_CONTAINER}\n  else\n    # preloading pause image. It will be used in preloader and will be\n    # useful for staging builds where access_token is needed to pull the image\n    local access_token=\"\";\n\n    if access_token=$(get-credentials); then\n      \"${KUBE_BIN}/crictl\" pull --creds \"oauth2accesstoken:${access_token}\" ${GKE_CONTAINERD_INFRA_CONTAINER}\n    else\n      echo \"No access token. Pulling without it.\"\n      \"${KUBE_BIN}/crictl\" pull ${GKE_CONTAINERD_INFRA_CONTAINER}\n    fi\n  fi\n  record-preload-info \"pause\" \"${GKE_CONTAINERD_INFRA_CONTAINER}\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n\n  record-preload-info \"gke-exec-auth-plugin\" \"${plugin_hash}\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local manifests_tar_urls\n  while IFS= read -r url; do\n    manifests_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${KUBE_MANIFESTS_TAR_URL}\")\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" \\(-name '*.yaml' -or -name '*.yaml.in'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" \\(-name '*.manifest' -or -name '*.json'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/node-registration-checker.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/node-registration-checker.sh\" \"${KUBE_BIN}/\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/networkd-monitor.sh\" \"${KUBE_BIN}/networkd-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n\n  record-preload-info \"${manifests_tar}\" \"${manifests_tar_hash}\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=${HURL_GCS_URL:-$(get-metadata-value \"${hurl_gcs_att}\")}\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=${INPLACE_GCS_URL:-$(get-metadata-value \"${inplace_gcs_att}\")}\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat \u003e \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" \u003c\u003cEOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\nfunction install-auger {\n  echo \"Downloading auger binary\"\n  if [[ -f \"${KUBE_HOME}/bin/auger\" ]]; then\n    echo \"auger is already installed\"\n    return\n  fi\n  AUGER_STORE_PATH=\"${AUGER_STORE_PATH:-https://storage.googleapis.com/gke-release-staging/auger}\"\n  AUGER_VERSION=\"${AUGER_VERSION:-v1.0.0-gke.1}\"\n  download-or-bust \"\" \"${AUGER_STORE_PATH}/${AUGER_VERSION}/auger.sha1\"\n  sha1=\"$(cat auger.sha1)\"\n  readonly sha1 # Declare readonly separately to avoid masking error values.\n  rm -f \"auger.sha1\"\n  download-or-bust \"${sha1}\" \"${AUGER_STORE_PATH}/${AUGER_VERSION}/auger\"\n  mv \"${KUBE_HOME}/auger\" \"${KUBE_HOME}/bin/auger\"\n  chmod a+x \"${KUBE_HOME}/bin/auger\"\n  record-preload-info \"auger\" \"${sha1}\"\n}\n\n# Extract etcdctl binary from etcd image.\nfunction install-etcdctl {\n  echo \"Installing etcdctl binary\"\n  if [[ -f \"${KUBE_HOME}/bin/etcdctl\" ]]; then\n    echo \"etcdctl is already installed\"\n    return\n  fi\n  local -r etcd_image=\"gcr.io/gke-master-images/etcd:${ETCDCTL_VERSION}\"\n  container_id=\"$(docker create \"${etcd_image}\" sh)\"\n  readonly containerId\n  docker cp \"${container_id}:usr/local/bin/etcdctl\" \"${KUBE_HOME}/bin/etcdctl\"\n  chmod a+x \"${KUBE_HOME}/bin/etcdctl\"\n  docker rm \"${container_id}\"\n  docker rmi \"${etcd_image}\"\n}\n\nfunction install-gcfsd {\n  echo \"Downloading Riptide FUSE client\"\n  if is-preloaded \"gcfsd\" \"${RIPTIDE_FUSE_VERSION}\"; then\n    echo \"gcfsd is preloaded.\"\n    return\n  fi\n\n  if [[ \"${HOST_ARCH}\" == \"arm64\" ]]; then\n    RIPTIDE_FUSE_STORE_PATH=\"https://storage.googleapis.com/${RIPTIDE_FUSE_BUCKET}/gcfsd/${RIPTIDE_FUSE_VERSION}/arm64\"\n  else\n    RIPTIDE_FUSE_STORE_PATH=\"https://storage.googleapis.com/${RIPTIDE_FUSE_BUCKET}/gcfsd/${RIPTIDE_FUSE_VERSION}\"\n  fi\n\n  if [[ \"${RIPTIDE_FUSE_VERSION}\" \u003e v0.19.0 ]] \u0026\u0026 [[ \"${RIPTIDE_FUSE_VERSION}\" != v0.4.0 ]] ; then\n    download-or-bust \"\" \"${RIPTIDE_FUSE_STORE_PATH}/gcfsd.tar.gz\"\n  fi\n  download-or-bust \"\" \"${RIPTIDE_FUSE_STORE_PATH}/gcfsd\"\n  mv \"${KUBE_HOME}/gcfsd\" \"${KUBE_HOME}/bin/gcfsd\"\n  chmod a+x \"${KUBE_HOME}/bin/gcfsd\"\n  record-preload-info \"gcfsd\" \"${RIPTIDE_FUSE_VERSION}\"\n}\n\nfunction install-riptide-snapshotter {\n  echo \"Downloading Riptide snapshotter\"\n  if is-preloaded \"containerd-gcfs-grpc\" \"${RIPTIDE_SNAPSHOTTER_VERSION}\"; then\n    echo \"containerd-gcfs-grpc is preloaded.\"\n    return\n  fi\n  RIPTIDE_SNAPSHOTTER_STORE_PATH=\"https://storage.googleapis.com/${RIPTIDE_SNAPSHOTTER_BUCKET}/gcfs-snapshotter/${RIPTIDE_SNAPSHOTTER_VERSION}\"\n  if [[ \"${RIPTIDE_SNAPSHOTTER_VERSION}\" \u003e v1.4-2 ]]; then\n    download-or-bust \"\" \"${RIPTIDE_SNAPSHOTTER_STORE_PATH}/containerd-gcfs-grpc.tar.gz\"\n  fi\n\n  if [[ \"${HOST_ARCH}\" == \"arm64\" ]]; then\n    RIPTIDE_SNAPSHOTTER_BINARY=\"containerd-gcfs-grpc-arm64\"\n  else\n    RIPTIDE_SNAPSHOTTER_BINARY=\"containerd-gcfs-grpc\"\n  fi\n\n  download-or-bust \"\" \"${RIPTIDE_SNAPSHOTTER_STORE_PATH}/${RIPTIDE_SNAPSHOTTER_BINARY}\"\n  mv \"${KUBE_HOME}/${RIPTIDE_SNAPSHOTTER_BINARY}\" \"${KUBE_HOME}/bin/containerd-gcfs-grpc\"\n  chmod a+x \"${KUBE_HOME}/bin/containerd-gcfs-grpc\"\n  record-preload-info \"containerd-gcfs-grpc\" \"${RIPTIDE_SNAPSHOTTER_VERSION}\"\n}\n\n# Install Riptide FUSE client and Riptide snapshotter\nfunction install-riptide {\n  install-gcfsd\n  install-riptide-snapshotter\n}\n\nfunction configure-cgroup-mode {\n  if which cgroup_helper \u003e /dev/null 2\u003e\u00261; then\n    if [[ \"${CGROUP_MODE:-}\" == \"v1\" ]] \u0026\u0026 cgroup_helper show | grep -q 'unified'; then\n      cgroup_helper set hybrid\n      echo \"set cgroup config to hybrid, now rebooting...\"\n      reboot\n    elif [[ \"${CGROUP_MODE:-}\" == \"v2\" ]] \u0026\u0026 cgroup_helper show | grep -q 'hybrid'; then\n      cgroup_helper set unified\n      echo \"set cgroup config to unified, now rebooting...\"\n      reboot\n    fi\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  # Deliberately word split load_image_command\n  # shellcheck disable=SC2086\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get \u003e/dev/null 2\u003e\u00261; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  # shellcheck disable=SC2086\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update \u0026\u0026 \\\n    apt-get install -y --no-install-recommends \"${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\"\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  # shellcheck disable=SC2086\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update \u0026\u0026 \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # TODO(https://github.com/containerd/containerd/issues/2901): Remove this check once containerd has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n      exit 2\n    fi\n    # containerd versions have slightly different url(s), so try both\n    # shellcheck disable=SC2086\n    ( curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" \\\n      || curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    # TODO: Remove this check once runc has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install runc in non-amd64. Bailing out...\"\n      exit 2\n    fi\n    # shellcheck disable=SC2086\n    curl ${CURL_FLAGS} \\\n      --location \\\n      \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.${HOST_ARCH}\" --output /usr/sbin/runc \\\n    \u0026\u0026 chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker \u003e/dev/null 2\u003e\u00261; then\n      install-docker\n      if ! command -v docker \u003e/dev/null 2\u003e\u00261; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr \u003e/dev/null 2\u003e\u00261; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd \u003e/dev/null 2\u003e\u00261; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc \u003e/dev/null 2\u003e\u00261; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local server_binary_tar_urls\n  while IFS= read -r url; do\n    server_binary_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${SERVER_BINARY_TAR_URL}\")\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n\n    record-preload-info \"${server_binary_tar}\" \"${server_binary_tar_hash}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" \u0026\u0026 -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # Preload pause image\n  preload-pause-image\n\n  # Copy health check binaries to a tmpfs mount to reduce block IO usage.\n  setup-shm-healthcheck-binaries\n\n  # TODO(awly): include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] \u0026\u0026 \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\nfunction setup-shm-healthcheck-binaries() {\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    return\n  fi\n  if [[ \"${ENABLE_SHM_HEALTHCHECK_BINARIES:-}\" != \"true\" ]];then\n    return\n  fi\n\n  local -r shm_dir=\"${HEALTHCHECK_SHM_DIR:-/dev/kube_shm}\"\n  local -r shm_bin_dir=\"${shm_dir}/bin\"\n\n  mkdir -p \"$shm_dir\"\n  mount -t tmpfs -o exec none \"$shm_dir\"\n  mkdir \"${shm_bin_dir}\"\n\n  cp -f \"${KUBE_BIN}/crictl\" \"${shm_bin_dir}/crictl\"\n  cp -f \"$(which curl)\" \"${shm_bin_dir}/curl\"\n}\n\nfunction install-extra-node-requirements() {\n  if [[ \"${KUBERNETES_MASTER:-}\" != \"false\" ]]; then\n    return\n  fi\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    # M4A is not relevant on ARM\n    if [[ \"${HOST_ARCH}\" == \"amd64\" ]]; then\n      install-m4a-apparmor-profile\n    fi\n  fi\n}\n\n# This function detects the platform/arch of the machine where the script runs,\n# and sets the HOST_PLATFORM and HOST_ARCH environment variables accordingly.\n# Callers can specify HOST_PLATFORM_OVERRIDE and HOST_ARCH_OVERRIDE to skip the detection.\n# This function is adapted from the detect_client_info function in cluster/get-kube-binaries.sh\n# and kube::util::host_os, kube::util::host_arch functions in hack/lib/util.sh\n# This function should be synced with detect_host_info in ./configure-helper.sh\nfunction detect_host_info() {\n  HOST_PLATFORM=${HOST_PLATFORM_OVERRIDE:-\"$(uname -s)\"}\n  case \"${HOST_PLATFORM}\" in\n    Linux|linux)\n      HOST_PLATFORM=\"linux\"\n      ;;\n    *)\n      echo \"Unknown, unsupported platform: ${HOST_PLATFORM}.\" \u003e\u00262\n      echo \"Supported platform(s): linux.\" \u003e\u00262\n      echo \"Bailing out.\" \u003e\u00262\n      exit 2\n  esac\n\n  HOST_ARCH=${HOST_ARCH_OVERRIDE:-\"$(uname -m)\"}\n  case \"${HOST_ARCH}\" in\n    x86_64*|i?86_64*|amd64*)\n      HOST_ARCH=\"amd64\"\n      ;;\n    aHOST_arch64*|aarch64*|arm64*)\n      HOST_ARCH=\"arm64\"\n      ;;\n    *)\n      echo \"Unknown, unsupported architecture (${HOST_ARCH}).\" \u003e\u00262\n      echo \"Supported architecture(s): amd64 and arm64.\" \u003e\u00262\n      echo \"Bailing out.\" \u003e\u00262\n      exit 2\n      ;;\n  esac\n}\n\n# Retries a command forever with a delay between retries.\n# Args:\n#  $1    : delay between retries, in seconds.\n#  $2... : the command to run.\nfunction retry-forever {\n  local -r delay=\"$1\"\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $* failed, retrying after ${delay}s\"\n    sleep \"${delay}\"\n  done\n}\n\n# Initializes variables used by the log-* functions.\n#\n# get-metadata-value must be defined before calling this function.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-init {\n  # Used by log-* functions.\n  LOG_CLUSTER_ID=${LOG_CLUSTER_ID:-$(get-metadata-value 'instance/attributes/cluster-uid' 'get-metadata-value-error')}\n  LOG_INSTANCE_NAME=$(hostname || echo 'hostname-error')\n  LOG_BOOT_ID=$(journalctl --list-boots | grep -E '^ *0' | awk '{print $2}' || echo 'journalctl-error')\n  declare -Ag LOG_START_TIMES\n  declare -ag LOG_TRAP_STACK\n\n  LOG_STATUS_STARTED='STARTED'\n  LOG_STATUS_COMPLETED='COMPLETED'\n  LOG_STATUS_ERROR='ERROR'\n}\n\n# Sets an EXIT trap.\n# Args:\n#   $1:... : the trap command.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-push {\n  local t=\"${*:1}\"\n  LOG_TRAP_STACK+=(\"${t}\")\n  # shellcheck disable=2064\n  trap \"${t}\" EXIT\n}\n\n# Removes and restores an EXIT trap.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-pop {\n  # Remove current trap.\n  unset 'LOG_TRAP_STACK[-1]'\n\n  # Restore previous trap.\n  if [ ${#LOG_TRAP_STACK[@]} -ne 0 ]; then\n    local t=\"${LOG_TRAP_STACK[-1]}\"\n    # shellcheck disable=2064\n    trap \"${t}\" EXIT\n  else\n    # If no traps in stack, clear.\n    trap EXIT\n  fi\n}\n\n# Logs the end of a bootstrap step that errored.\n# Args:\n#  $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-error {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_ERROR}\" \"encountered non-zero exit code\"\n}\n\n# Wraps a command with bootstrap logging.\n# Args:\n#   $1    : bootstrap step name.\n#   $2... : the command to run.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-wrap {\n  local bootstep=\"$1\"\n  local command=\"${*:2}\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n  $command\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Logs a bootstrap step start. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-start {\n  local bootstep=\"$1\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n}\n\n# Logs a bootstrap step end. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-end {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Writes a log proto to stdout.\n# Args:\n#   $1: bootstrap step name.\n#   $2: status. Either 'STARTED', 'COMPLETED', or 'ERROR'.\n#   $3: optional status reason.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-proto {\n  local bootstep=\"$1\"\n  local status=\"$2\"\n  local status_reason=\"${3:-}\"\n\n  # Get current time.\n  local current_time\n  current_time=\"$(date --utc '+%s.%N')\"\n  # ...formatted as UTC RFC 3339.\n  local timestamp\n  timestamp=\"$(date --utc --date=\"@${current_time}\" '+%FT%T.%NZ')\"\n\n  # Calculate latency.\n  local latency='null'\n  if [ \"${status}\" == \"${LOG_STATUS_STARTED}\" ]; then\n    LOG_START_TIMES[\"${bootstep}\"]=\"${current_time}\"\n  else\n    local start_time=\"${LOG_START_TIMES[\"${bootstep}\"]}\"\n    unset 'LOG_START_TIMES['\"${bootstep}\"']'\n\n    # Bash cannot do non-integer math, shell out to awk.\n    latency=\"$(echo \"${current_time} ${start_time}\" | awk '{print $1 - $2}')s\"\n\n    # The default latency is null which cannot be wrapped as a string so we must\n    # do it here instead of the printf.\n    latency=\"\\\"${latency}\\\"\"\n  fi\n\n  printf '[cloud.kubernetes.monitoring.proto.SerialportLog] {\"cluster_hash\":\"%s\",\"vm_instance_name\":\"%s\",\"boot_id\":\"%s\",\"timestamp\":\"%s\",\"bootstrap_status\":{\"step_name\":\"%s\",\"status\":\"%s\",\"status_reason\":\"%s\",\"latency\":%s}}\\n' \\\n  \"${LOG_CLUSTER_ID}\" \"${LOG_INSTANCE_NAME}\" \"${LOG_BOOT_ID}\" \"${timestamp}\" \"${bootstep}\" \"${status}\" \"${status_reason}\" \"${latency}\"\n}\n\n######### Main Function ##########\nlog-init\ndetect_host_info\n\n# Preloader will source this script, and skip the main function. The preloader\n# will choose what to preload by calling install-X functions directly.\n# When configure.sh is sourced by the preload script, $0 and $BASH_SOURCE are\n# different. $BASH_SOURCE still contains the path of configure.sh, while $0 is\n# the path of the preload script.\nif [[ \"$0\" != \"$BASH_SOURCE\" \u0026\u0026 \"${IS_PRELOADER:-\"false\"}\" == \"true\" ]]; then\n  echo \"Running in preloader instead of VM bootsrapping. Skipping installation steps as preloader script will source configure.sh and call corresponding functions.\"\n  return\nfi\n\nlog-start 'ConfigureMain'\necho \"Start to install kubernetes files\"\n\n# if install fails, message-of-the-day (motd) will warn at login shell\nlog-wrap 'SetBrokenMotd' set-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  log-wrap 'InstallHurl' install-hurl\n  log-wrap 'InstallInplace' install-inplace\nfi\n\n# download and source kube-env\nlog-wrap 'DownloadKubeEnv' download-kube-env\nlog-wrap 'SourceKubeEnv' source \"${KUBE_HOME}/kube-env\"\n\nlog-wrap 'ConfigureCgroupMode' configure-cgroup-mode\n\nlog-wrap 'DownloadKubeletConfig' download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'DownloadKubeMasterCerts' download-kube-master-certs-hurl\nfi\n\n# ensure chosen container runtime is present\nlog-wrap 'EnsureContainerRuntime' ensure-container-runtime\n\n# binaries and kube-system manifests\nlog-wrap 'InstallKubeBinaryConfig' install-kube-binary-config\n\nif [[ \"${ENABLE_GCFS:-\"\"}\" == \"true\" ]]; then\n  log-wrap 'InstallRiptide' install-riptide\nfi\n\n# extra node requirements\nlog-wrap 'InstallExtraNodeRequirements' install-extra-node-requirements\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'InplaceRunOnce' retry-forever 30 inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\nlog-end 'ConfigureMain'\n",
              "created-by": "projects/352350778257/zones/us-central1-c/instanceGroupManagers/gke-demo-cluster-main-fda3b6c7-grp",
              "disable-legacy-endpoints": "true",
              "gci-metrics-enabled": "true",
              "gci-update-strategy": "update_disabled",
              "google-compute-enable-pcid": "true",
              "instance-template": "projects/352350778257/global/instanceTemplates/gke-demo-cluster-main-fda3b6c7",
              "kube-env": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=60m,memory=435Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-balanced,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-cpu-scaling-level=1,cloud.google.com/gke-logging-variant=DEFAULT,cloud.google.com/gke-max-pods-per-node=110,cloud.google.com/gke-nodepool=main,cloud.google.com/gke-os-distribution=cos,cloud.google.com/gke-provisioning=standard,cloud.google.com/gke-stack-type=IPV4,cloud.google.com/machine-family=g1,cloud.google.com/private-node=false;arch=amd64;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMRENDQXBTZ0F3SUJBZ0lRRTFCbVEvRG5DZWt5ZGtFbmZFQ0VqekFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlSaE9USTJOalUwWXkwNFpHUTJMVFJsTURJdFlXVTFOQzFsTXpZNFptRTFOVGN5TWpFdwpJQmNOTWpNd05qSTFNakl5TnpRd1doZ1BNakExTXpBMk1UY3lNekkzTkRCYU1DOHhMVEFyQmdOVkJBTVRKR0U1Ck1qWTJOVFJqTFRoa1pEWXROR1V3TWkxaFpUVTBMV1V6TmpobVlUVTFOekl5TVRDQ0FhSXdEUVlKS29aSWh2Y04KQVFFQkJRQURnZ0dQQURDQ0FZb0NnZ0dCQUwyOENPSVYzbjdIcDVGTnRSSGFnbVlMeldDNHFuMGdBRXVIdmZLaQpHVnZDL1piYVhBT0x3YXRCOTczcnllRVBoTDRUOXZSTTc4YklDY3JKUWNzK2MrVmY0NnNHTm9CbjlhSUQ2Qm54CkY0SXRjODA0cE9TUVdOWVdxTkVKU25DMEdBN3RuSWs4S2gzc2ZFMnY5UlRxQlBrbldGbG9ON3ZOdFJ2ZmJlTTEKM3JUYytUQ0lwVWJFdXp5VHVnSjVMWmhkU01VVDBzM2kwbndrL3JnTFNPQzZJcnpqR1kySlUwSDUvNXQxekZxUApMZFBKZ253Mlk0SVMwbktNVVFmdm9lSThmcjZrL1lHNTVGdU9UMzZ5M3FrekROUW13clhaY1JxZXluSHFoOUJhCjVFYXZZVTBCRlFQRkNQdUg3Q2k4dXl3SVhIdEdNekFrTWNIcEg2U1ZEdGlOTnZzVWQyTEpjaXpwcnpobnVOK08KU3RPK2FVRElGMDFLcFE0eGNVcTc0a3Q1QWJMRVZkaHRZZGdGazN2ZzlKU3JINmMyV1BaTVRqaDF6WE5SZHlFTQpodVloQzh6MlJLN04yOUVEUWdmekc2TWFvZ0FWSy9FTE00TTgwRkluMUVPSjNqaVpmNm1NQ2FhNVVIMiswSGkxCnE1SlpvdnF5WlZOYk00akgvMithUnYwdkF3SURBUUFCbzBJd1FEQU9CZ05WSFE4QkFmOEVCQU1DQWdRd0R3WUQKVlIwVEFRSC9CQVV3QXdFQi96QWRCZ05WSFE0RUZnUVVmbWVBZmR4dlBQUVV5K1Y0MlBlNzJ3U1JpWmN3RFFZSgpLb1pJaHZjTkFRRUxCUUFEZ2dHQkFEbWhrUlpOMXRUcXlFd3J5aE9GdG9WMFNLY3dEUXViMVBMZ1A1NzF1dlNGCmQ3Vml1ajgzMW1HanpKNTFKZENGemlmTjk3WFMxTHZhNHpOV1VRMXEraEM1TDVac0NkSjFYRTcyV01JMnNDM1YKMEp5NTFIaWY1ZjU4OFVORzZseTBlN09sakpVd3hOUXVsWWFldFU3STVZbDVoclVXbUgyVldNTUM4bGFaSVBmRApRRlRlZitnVEVjVitWblVnRUtlSWlUQUY1TU9WZFlKOVBGM2NiWjZIb3B0VWxTU3NyQ3VNaGxQRFIvc0o1RlFtCkw5amtRNmw3MzRLQWRLckhudHFwcWN0bDh3QzZMeGtGaC9UWEo2SDdrd05UcjdRelpoZHVmR0I3N2lHNzYzVVkKQkFCY2tvSjQ0cUVhWDRzUTBFYkRyZUJmRVBVc2pQb2F0SnhXSXJkVU12OENNVVV0SDgrZWdGVDU2djZBL0paWgpoTzY3MWVaMU1vWTRFSUFwUno5VC8vNGdkWDlXZmdSd3VPQ0RZNzRGVHYxNTZ2M28wQ084TGp5MmtiRnIyZ29LCjFVV1NwdDYxWmNFelBiYUFJTEgraTV5VlhHZUE5QnhjTDZtVVBya3o0a2VFbCtDNmVGZDhIajRDKzRPbnlUWk8KM0lCSko1T0ZFMUp4SkRmb0hlR3pSUT09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\nCLUSTER_IP_RANGE: 10.0.0.0/14\nCLUSTER_NAME: demo-cluster\nCNI_HASH: ba28765e2939d398dc101ff5543e62a14d132a113102b371af8da86722a4dfbfb3cc5121e6cbdb349e5d9d892e66f034ba24d0b4acd2f1df942c0cd9bcc5723a\nCNI_SHA1: a687a7150d8201ac374b1915829c80ab3cf0c774\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v1.0.1-gke.4\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v1.0.1-gke.4\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"false\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.3.240.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODE_REGISTRATION_CHECKER: \"true\"\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SHM_HEALTHCHECK_BINARIES: \"true\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2023-06-25T23:27:40+00:00\"\nEXEC_AUTH_PLUGIN_HASH: 1e3e03770805fd4f670f51f4f138f2f9af0ffe16c531d6512bcaec02aab98cec7977da5a84ffbc6509e02989db613c1535f0e14af871078b9520a9f2325374b4\nEXEC_AUTH_PLUGIN_LICENSE_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/8e4840462445ac0edd615a1e6175f44efda4908a/LICENSE\nEXEC_AUTH_PLUGIN_SHA1: 96035ca5744c1d4bd797974ac8f3e1ccbf105ea7\nEXEC_AUTH_PLUGIN_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/8e4840462445ac0edd615a1e6175f44efda4908a/linux_amd64/gke-exec-auth-plugin\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nEXTRA_POD_SYSCTLS: net.ipv6.conf.all.disable_ipv6=1,net.ipv6.conf.default.disable_ipv6=1\nFEATURE_GATES: DynamicKubeletConfig=false,InTreePluginAWSUnregister=true,InTreePluginAzureDiskUnregister=true,InTreePluginOpenStackUnregister=true,InTreePluginvSphereUnregister=true,DisableKubeletCloudCredentialProviders=false,RotateKubeletServerCertificate=true,ExecProbeTimeout=false,CSIMigrationGCE=true\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-demo-cluster-3f5a8ffb\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.3.240.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: 8a7686b5b245064f4758be7c5c82aec2a8cc4447e2222d7719861196c61efd9d8da76f8f4ce5a5a70c298bc21d645501eec543e8b57618dfd2d18ec74efabb1a\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release/kubernetes/release/v1.25.8-gke.1000/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.25.8-gke.1000/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.25.8-gke.1000/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: IlaLESxGnsMc58Y4MI2J7ohD63-F0kz515gBMPecI2I=\nKUBELET_ARGS: --v=2 --cloud-provider=external --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter\n  --cert-dir=/var/lib/kubelet/pki/ --kubeconfig=/var/lib/kubelet/kubeconfig --max-pods=110\n  --volume-plugin-dir=/home/kubernetes/flexvolume --node-status-max-images=25 --container-runtime=remote\n  --container-runtime-endpoint=unix:///run/containerd/containerd.sock --runtime-cgroups=/system.slice/containerd.service\n  --registry-qps=10 --registry-burst=20\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 10.128.0.5\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release/kubernetes/release/v1.25.8-gke.1000/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.25.8-gke.1000/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.25.8-gke.1000/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: f8465a47628522468241cf09fc186706392371bf28f5745ec666f0c875e51523b845298418aa2364ef20d8e9f8d0136404c322e7b7b2aa2bcde2ddc79c0d1764\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release/kubernetes/release/v1.25.8-gke.1000/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.25.8-gke.1000/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.25.8-gke.1000/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.3.240.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nTPM_BOOTSTRAP_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURyRENDQWhTZ0F3SUJBZ0lSQU52OXFHUEd6MWFIaWI2QVQ3R0tONmt3RFFZSktvWklodmNOQVFFTEJRQXcKTHpFdE1Dc0dBMVVFQXhNa1lUa3lOalkxTkdNdE9HUmtOaTAwWlRBeUxXRmxOVFF0WlRNMk9HWmhOVFUzTWpJeApNQjRYRFRJek1EWXlOVEl6TWpVME1Wb1hEVEk0TURZeU16SXpNamMwTVZvd0hERWFNQmdHQTFVRUF4TVJhM1ZpClpXeGxkQzFpYjI5MGMzUnlZWEF3Z2dFaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLQW9JQkFRREMKQ1VzTHFhUVRmbGlBb29aMUFlcE5JcXE5am90OXI1c21kM3dmYURBTzN6NWxNRWxkOG1oMEZUeHVjUkhJZE5tdgpOdk9ON1JTdTVyUExZSk44TkpxRzhaMlQrdGFEeUdTWUNDSG5JR3hpMWd1Q3JsTnJHY2NtTTF1dWVBUkNsZ2NrCnhsd3diT2d4U2ZvTWFvU2RwUVcxMEFnMkdTVTZZRHlibnFOSE1oWXlDb01qdjZ5M3RlZ29jeXdFNjZtMjNadTUKV0xLbU5vYlcyLy95cm9kY292V1I1SGl0M2pNdFlVOG9HcGQ0dnhkVG9wOTdLeWJKc2NmUGppZ3ZGL3VTNHFDMApJeFBZSlBueDJpOXhHMXlhaG1QMmtrSXhuMmtFTlJ1b1ZjYVVxb3IxcjIzWW5TYWZ3dU9sdlA5VlJTNDFCNkdECml6TlU5eThMWWpvN21GUlhyc2RMQWdNQkFBR2pWakJVTUE0R0ExVWREd0VCL3dRRUF3SUZvREFUQmdOVkhTVUUKRERBS0JnZ3JCZ0VGQlFjREFqQU1CZ05WSFJNQkFmOEVBakFBTUI4R0ExVWRJd1FZTUJhQUZINW5nSDNjYnp6MApGTXZsZU5qM3U5c0VrWW1YTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCZ1FCM081cDNqNmkrZnVnanB5VXJrU2FCCkZOY3VTWEkwNG9HRGcrR3hDRVR5Tkg3NDZnT2VQUmZuWWYzN1hlSC9LQTl4cjJlSThTUVNOaTdTazZPVmt0dlQKZjhtQlNMMHd4MXo2bDNqRGgvczl3YWpoQXpHR1NqVVRBbjhPdkxQdEVoQTZGQy9SekdRdUppbm82ZzY4VFZ1aApVZE5Ha0ZKV0tXVjg5dDJhcmFaZEs3bkQ0UllCR2JGVEVGK2Z4cTBsQ0h3NXJmbDZlcGEwa203ajJpNURkWVBtCi9WeThlVk54cTFremV0aWErdEdaM2NMa2hoM281ZEVBWlRWV2RLaDA0allGTmtDY3dEM1hrRWlUaHl6REVmQ0QKVnpDYVEweEw3eFpIZFk2Uys4NzRJT2NqQjh6dWF2bzR0eEhHQnpzejJLVElWUGFZVWtxbGh0V3lJWVB2SU0xYgpEQVIrczRPc3BVaE1YUEJjTytWcmNob0N3K1Vna3o3Yk9sOEluRndJZmhvRmN4K3B0dW5FMnRCS3UwQSswWmJzClFJbVk3cmxGcXlkeVMzdm1teGEyQk1mblU5SlMxUTByUFJ5bklRKzBsWk54dWlFb2x6aDhqck9XN1lEVWR2Vi8KbjM0UUVJUE5lSi83a0FZNzVsVFR3VHdJcDdKdk9QaksweWcvK2NreWdFND0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\nTPM_BOOTSTRAP_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcEFJQkFBS0NBUUVBd2dsTEM2bWtFMzVZZ0tLR2RRSHFUU0txdlk2TGZhK2JKbmQ4SDJnd0R0OCtaVEJKClhmSm9kQlU4Ym5FUnlIVFpyemJ6amUwVXJ1YXp5MkNUZkRTYWh2R2RrL3JXZzhoa21BZ2g1eUJzWXRZTGdxNVQKYXhuSEpqTmJybmdFUXBZSEpNWmNNR3pvTVVuNkRHcUVuYVVGdGRBSU5oa2xPbUE4bTU2alJ6SVdNZ3FESTcrcwp0N1hvS0hNc0JPdXB0dDJidVZpeXBqYUcxdHYvOHE2SFhLTDFrZVI0cmQ0ekxXRlBLQnFYZUw4WFU2S2ZleXNtCnliSEh6NDRvTHhmN2t1S2d0Q01UMkNUNThkb3ZjUnRjbW9aajlwSkNNWjlwQkRVYnFGWEdsS3FLOWE5dDJKMG0KbjhManBiei9WVVV1TlFlaGc0c3pWUGN2QzJJNk81aFVWNjdIU3dJREFRQUJBb0lCQUNpMmVIZVcvYVZWY2s1egpTNUVMZU5UOGZDVFAzdmJkUE1taWNubklpNlRqTkoxWXQxd3QrN3EzcGZscVloZlVaTVI5M0RhZ1V5R3JxSGY0CjZKazhGRnhTSUFVbnNaRHZJQ1JDT0pMZFc4Q1ZOczhSc3RFYkZJMHdZNEZGRDJmRlFQUjNabXFHdjJWd0p6WXAKdDIrNGEyMU5uQnQxeFRqdGJtb2NyQmZKSzUwTjkrMlE0NTZ1M1lTQy9Qa2RtUHFpa3dPaGRFNzhFYnRmVEV5RgpyRVFGTTdGdllKeDY1bFNJTEc4b1lnMU1LMVdUdHAvQitUUzIrMlVvNHpoNDhOc1hoNmhFVTdjZ3J0MEN4K3ByCmJMZDdVRGo5Z0YrOVM4NjNwTE5UdTZrSi94U3ZNUG5jbGtvY3RVREU5OGY5VGwwY2pxRXIxMmw5NkZwWCsyVk0KRVpSZXBHRUNnWUVBN0FBendJZE5GMTJPbWk3RklWOG1NZW9RcmVCRG5YaHZlcjhDbnlqdC83emduSmhSU2EyRQpGWWxaUDE5MWYvbW05YUovYTd2S2VHRlpkOUZaRDRDTGJycVZLc0RQMnJvZXZpbU5qVk5hcTFEV1lwdmpKeUdqCitjSXB6VUVTTzArRFNweFFFWGhQVk0vaFVuK3VXa2hZZk1OTm5OeHVkSFpPSmpUOXZjU2JzQnNDZ1lFQTBucTIKeG14cnltR2Z0ekxWUkxRUWNnMmFDNmMrSVB6YVFRZkdCOGdtRk5xL2JHTElPcFlhRllqWXZkaC9MV09rOFVuNgo5dTZNb0N0RjV3UzhXTS9hVExHWndFc1BybXlPQk5CckpJSHhqSmdtRTFxVHhqSFBkQ3JjRzZRLzNEL1VwUlpCCnBpcUt0ZUoxSkZycjJDU09BcXNvVmNvdWVqTmUvMGdOVHEvUW1KRUNnWUVBNVJ2QklneDMrOUg0cVpmMENsUzcKMk1NNTFBTWV3UlgxYTcxWmh6Z043VExvL3owajFSb2RXMmNPZkdab3hJZVIzVzhXc25rSnMxb1dxQ3BWZ3FZeApOcHJ1U3lZSjQzYkNkNndSWG56b1RkNVpjanVTQnlBeWR6cFdxSXVlYm5QZnFxUWJXd3BvUVpiYVVPUGhXSVpaCldTMmxBRDVEQU04RlNUUXlqWEw4RGJjQ2dZQTFXNUtXUHNvY3BoNzlMRS9RZU8xcVhIUmUyK2p1Sit1VWJNb1IKRXZaRWR5ZnI3Q2JpWTBiOWlwR1hueGl1Z3dJL2dRZTBMY2xNbVd2Qkl2dzBiNHpod0d3L3lVZVNha2FlaGMrRAprOFdPWk12U1FEWVNHbktDK3BLT0YxZHhHR1ZwN0hoOERYRFlweTRYSjAxK245VzRhM2R3T0M4TUg1WEhsWlo2CkNpd1JZUUtCZ1FDUDRhYUlLZkIvYmNscXI3RnE4ekhuT0ZweVR4Q1IvejVjNlJuM0lvL2N3OG50b0h0VldjWVMKQS95VHZ1VkQ5ZWJQMFBEL2luZUwwNE9BQm5WQ3NiQnpBeVVjYUhBWDhWZjNHaUlmR2l3ekVha1RQQlh5dWZGNgoxbGlFYXl3bU9UNkptdHdQanYyMnZNUmFaUHlRMExhZ2VINklGMm9LMFJQNm8rU0haUFlZWXc9PQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: us-central1-c\n",
              "kube-labels": "cloud.google.com/gke-boot-disk=pd-balanced,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-cpu-scaling-level=1,cloud.google.com/gke-logging-variant=DEFAULT,cloud.google.com/gke-max-pods-per-node=110,cloud.google.com/gke-nodepool=main,cloud.google.com/gke-os-distribution=cos,cloud.google.com/gke-provisioning=standard,cloud.google.com/gke-stack-type=IPV4,cloud.google.com/machine-family=g1,cloud.google.com/private-node=false",
              "kubeconfig": "apiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://10.128.0.5\n    certificate-authority: '/etc/srv/kubernetes/pki/ca-certificates.crt'\n  name: default-cluster\ncontexts:\n- context:\n    cluster: default-cluster\n    namespace: default\n    user: exec-plugin-auth\n  name: default-context\ncurrent-context: default-context\nusers:\n- name: exec-plugin-auth\n  user:\n    exec:\n      apiVersion: \"client.authentication.k8s.io/v1beta1\"\n      command: '/home/kubernetes/bin/gke-exec-auth-plugin'\n      args: [\"--cache-dir\", '/var/lib/kubelet/pki/']\n",
              "kubelet-config": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.3.240.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  CSIMigrationGCE: true\n  DisableKubeletCloudCredentialProviders: false\n  DynamicKubeletConfig: false\n  ExecProbeTimeout: false\n  InTreePluginAWSUnregister: true\n  InTreePluginAzureDiskUnregister: true\n  InTreePluginOpenStackUnregister: true\n  InTreePluginvSphereUnregister: true\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 60m\n  ephemeral-storage: 41Gi\n  memory: 435Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n",
              "serial-port-logging-enable": "true",
              "user-data": "#cloud-config\n\nusers:\n  - name: kube-bootstrap-logs-forwarder\n    gecos: User the kube-bootstrap-logs-forwarder.service runs as.\n    system: true\n\nwrite_files:\n  - path: /etc/systemd/system/kube-bootstrap-logs-forwarder.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Forwards Kubernetes bootstrap logs to serial port.\n      Before=kube-node-installation.service\n\n      [Service]\n      User=kube-bootstrap-logs-forwarder\n      Group=systemd-journal\n      SupplementaryGroups=serial\n      ExecStart=journalctl --no-tail --no-pager --follow --utc --output short-iso --unit kube-node-installation --unit kube-node-configuration --unit kubelet\n      StandardOutput=tty\n      TTYPath=/dev/ttyS2\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      ExecStartPre=/usr/bin/curl --fail --retry 5 --retry-delay 3 --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      ExecStartPost=systemctl stop kube-bootstrap-logs-forwarder.service\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\n  - path: /etc/modprobe.d/sunrpc.conf\n    permissions: '0644'\n    owner: root\n    # The GKE metadata server uses ports 987-989, so the sunrpc range should be restricted to be below.\n    content: |\n      options sunrpc max_resvport=986\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-bootstrap-logs-forwarder.service\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
            },
            "metadata_fingerprint": "1buaaHWL3_0=",
            "metadata_startup_script": null,
            "min_cpu_platform": "",
            "name": "gke-demo-cluster-main-fda3b6c7-2xkm",
            "network_interface": [
              {
                "access_config": [
                  {
                    "nat_ip": "34.136.14.165",
                    "network_tier": "PREMIUM",
                    "public_ptr_domain_name": ""
                  }
                ],
                "alias_ip_range": [],
                "ipv6_access_config": [],
                "ipv6_access_type": "",
                "name": "nic0",
                "network": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/global/networks/default",
                "network_ip": "10.128.0.8",
                "nic_type": "",
                "queue_count": 0,
                "stack_type": "IPV4_ONLY",
                "subnetwork": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/regions/us-central1/subnetworks/default",
                "subnetwork_project": "k8s-k3s-386218"
              }
            ],
            "network_performance_config": null,
            "project": "k8s-k3s-386218",
            "reservation_affinity": null,
            "resource_policies": null,
            "scheduling": [
              {
                "automatic_restart": true,
                "instance_termination_action": "",
                "min_node_cpus": 0,
                "node_affinities": [],
                "on_host_maintenance": "MIGRATE",
                "preemptible": false,
                "provisioning_model": "STANDARD"
              }
            ],
            "scratch_disk": [],
            "self_link": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instances/gke-demo-cluster-main-fda3b6c7-2xkm",
            "service_account": [
              {
                "email": "352350778257-compute@developer.gserviceaccount.com",
                "scopes": [
                  "https://www.googleapis.com/auth/devstorage.read_only",
                  "https://www.googleapis.com/auth/logging.write",
                  "https://www.googleapis.com/auth/monitoring",
                  "https://www.googleapis.com/auth/service.management.readonly",
                  "https://www.googleapis.com/auth/servicecontrol",
                  "https://www.googleapis.com/auth/trace.append"
                ]
              }
            ],
            "shielded_instance_config": [
              {
                "enable_integrity_monitoring": true,
                "enable_secure_boot": false,
                "enable_vtpm": true
              }
            ],
            "tags": [
              "gke-demo-cluster-3f5a8ffb-node"
            ],
            "tags_fingerprint": "J1cGOA2A7iw=",
            "zone": "us-central1-c"
          },
          "sensitive_attributes": []
        },
        {
          "index_key": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instances/gke-demo-cluster-main-fda3b6c7-37gd",
          "schema_version": 0,
          "attributes": {
            "advanced_machine_features": null,
            "allow_stopping_for_update": null,
            "attached_disk": [],
            "boot_disk": [
              {
                "auto_delete": true,
                "device_name": "persistent-disk-0",
                "disk_encryption_key_raw": "",
                "disk_encryption_key_sha256": "",
                "initialize_params": [
                  {
                    "image": "https://www.googleapis.com/compute/v1/projects/gke-node-images/global/images/gke-1258-gke1000-cos-101-17162-127-42-v230330-c-cgpv1-pre",
                    "labels": {
                      "goog-gke-node": "",
                      "goog-gke-volume": "",
                      "goog-k8s-cluster-location": "us-central1-c",
                      "goog-k8s-cluster-name": "demo-cluster",
                      "goog-k8s-node-pool-name": "main"
                    },
                    "size": 100,
                    "type": "pd-balanced"
                  }
                ],
                "kms_key_self_link": "",
                "mode": "READ_WRITE",
                "source": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/disks/gke-demo-cluster-main-fda3b6c7-37gd"
              }
            ],
            "can_ip_forward": true,
            "confidential_instance_config": null,
            "cpu_platform": "Intel Haswell",
            "current_status": "RUNNING",
            "deletion_protection": false,
            "description": null,
            "desired_status": null,
            "enable_display": false,
            "guest_accelerator": [],
            "hostname": null,
            "id": "projects/k8s-k3s-386218/zones/us-central1-c/instances/gke-demo-cluster-main-fda3b6c7-37gd",
            "instance_id": "4892798820849906015",
            "label_fingerprint": "oxbNtz4VdcY=",
            "labels": {
              "goog-gke-node": "",
              "goog-k8s-cluster-location": "us-central1-c",
              "goog-k8s-cluster-name": "demo-cluster",
              "goog-k8s-node-pool-name": "main"
            },
            "machine_type": "g1-small",
            "metadata": {
              "cluster-location": "us-central1-c",
              "cluster-name": "demo-cluster",
              "cluster-uid": "3f5a8ffbae25412187837c1f034c66c50295e3b1a4354bef868e317f6ec6a26f",
              "configure-sh": "#!/usr/bin/env bash\n\n# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Due to the GCE custom metadata size limit, we split the entire script into two\n# files configure.sh and configure-helper.sh. The functionality of downloading\n# kubernetes configuration, manifests, docker images, and binary files are\n# put in configure.sh, which is uploaded via GCE custom metadata.\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n### Hardcoded constants\nDEFAULT_CNI_VERSION='v0.9.1'\nDEFAULT_CNI_HASH='b5a59660053a5f1a33b5dd5624d9ed61864482d9dc8e5b79c9b3afc3d6f62c9830e1c30f9ccba6ee76f5fb1ff0504e58984420cc0680b26cb643f1cb07afbd1c'\nDEFAULT_NPD_VERSION='v0.8.13'\nDEFAULT_NPD_HASH_AMD64='24e705d30b5839264cb64c54a19928a1a7e6fe7b8cba730f50bb737e920136f16410572f2bfe065a5f4aa1a77f9d2616d7dac37e9d4e1edd30b870c586937f65'\nDEFAULT_NPD_HASH_ARM64='f41858b118cd8c09351cc5518d554728324713b8ee77e71184ef856f89e9302560aefbc3bb9a43b37bce5cb272bc508f991c2c2e4e7e940aeac4384d8f4de5c1'\nDEFAULT_CRICTL_VERSION='v1.24.2-gke.3'\nDEFAULT_CRICTL_AMD64_SHA512='31203f35e1d857e32f55c169b7a9e9dc03009eb5b842684d948b10bc961f05970ca96673f7ef76aa73df5b1e5ec0f773812aaf49938924851c58720f6f32450f'\nDEFAULT_CRICTL_ARM64_SHA512='e4e8d80919b08e6d02905c13b92e1d1a6db78a52efdb8277f454666a7901c308667a1faf60714731f75ba48c3292d520e5277bc92877d6cb60f93cf3045f90c0'\nDEFAULT_MOUNTER_ROOTFS_VERSION='v1.0.0'\nDEFAULT_MOUNTER_ROOTFS_TAR_AMD64_SHA512='631330b7fa911d67e400b1d014df65a7763667d4afd4ecefe11a4a89dc9b8be626e5610d53b536c255a3ab488408ab2da8a0699d9fdad280cb3aa24bc2f30ab0'\nDEFAULT_MOUNTER_ROOTFS_TAR_ARM64_SHA512='83cf9ab7961627359654131abd2d4c4b72875d395c50cda9e417149b2eb53b784dfe5c2f744ddbccfe516e36dd64c716d69d161d8bc8b4f42a9207fe676d0bc1'\n###\n\n# This version needs to be the same as in gke/cluster/gce/gci/configure-helper.sh\nGKE_CONTAINERD_INFRA_CONTAINER=\"${CONTAINERD_INFRA_CONTAINER:-gke.gcr.io/pause:3.8@sha256:880e63f94b145e46f1b1082bb71b85e21f16b99b180b9996407d61240ceb9830}\"\n\nRIPTIDE_FUSE_BUCKET=\"${RIPTIDE_FUSE_BUCKET:-gke-release}\"\nRIPTIDE_SNAPSHOTTER_BUCKET=\"${RIPTIDE_SNAPSHOTTER_BUCKET:-gke-release}\"\nRIPTIDE_FUSE_VERSION=\"${RIPTIDE_FUSE_VERSION:-v0.150.0}\"\nRIPTIDE_SNAPSHOTTER_VERSION=\"${RIPTIDE_SNAPSHOTTER_VERSION:-v1.4-25}\"\n\n# Standard curl flags.\nCURL_FLAGS='--fail --silent --show-error --retry 5 --retry-delay 3 --connect-timeout 10 --retry-connrefused'\n\nfunction set-broken-motd {\n  cat \u003e /etc/motd \u003c\u003cEOF\nBroken (or in progress) Kubernetes node setup! Check the cluster initialization status\nusing the following commands.\n\nMaster instance:\n  - sudo systemctl status kube-master-installation\n  - sudo systemctl status kube-master-configuration\n\nNode instance:\n  - sudo systemctl status kube-node-installation\n  - sudo systemctl status kube-node-configuration\nEOF\n}\n\n# A function that fetches a GCE metadata value and echoes it out.\n# Args:\n#   $1 : URL path after /computeMetadata/v1/ (without heading slash).\n#   $2 : An optional default value to echo out if the fetch fails.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction get-metadata-value {\n  local default=\"${2:-}\"\n\n  local status\n  # shellcheck disable=SC2086\n  curl ${CURL_FLAGS} \\\n    -H 'Metadata-Flavor: Google' \\\n    \"http://metadata/computeMetadata/v1/${1}\" \\\n  || status=\"$?\"\n  status=\"${status:-0}\"\n\n  if [[ \"${status}\" -eq 0 || -z \"${default}\" ]]; then\n    return \"${status}\"\n  else\n    echo \"${default}\"\n  fi\n}\n\n# A function to fetch kube-env from GCE metadata server\n# or using hurl on the master if available\nfunction download-kube-env {\n  (\n    umask 077\n    local kube_env_path=\"/tmp/kube-env.yaml\"\n    if [[ \"$(is-master)\" == \"true\" \u0026\u0026 $(use-hurl) = \"true\" ]]; then\n      local kube_env_path=\"${KUBE_HOME}/kube-env.yaml\"\n      download-kube-env-hurl \"${kube_env_path}\"\n    else\n      local meta_path=\"http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env\"\n      echo \"Downloading kube-env via GCE metadata from ${meta_path} to ${kube_env_path}\"\n      # shellcheck disable=SC2086\n      retry-forever 10 curl ${CURL_FLAGS} \\\n        -H \"X-Google-Metadata-Request: True\" \\\n        -o \"${kube_env_path}\" \\\n        \"${meta_path}\"\n    fi\n\n    # Convert the yaml format file into a shell-style file.\n    eval \"$(python3 -c '''\nimport pipes,sys,yaml\nitems = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${kube_env_path}\" \u003e \"${KUBE_HOME}/kube-env\")\"\n\n    # Leave kube-env if we are a master\n    if [[ \"$(is-master)\" != \"true\" ]]; then\n      rm -f \"${kube_env_path}\"\n    fi\n  )\n}\n\n# A function to pull kube-env from HMS using hurl\nfunction download-kube-env-hurl {\n  local -r kube_env_path=\"$1\"\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r kube_env_hms_path=$(get-metadata-value \"instance/attributes/kube-env-path\")\n\n  echo \"Downloading kube-env via hurl from ${kube_env_hms_path} to ${kube_env_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${kube_env_path}\" \\\n    \"${kube_env_hms_path}\"\n  chmod 600 \"${kube_env_path}\"\n}\n\nfunction download-kubelet-config {\n  local -r dest=\"$1\"\n  echo \"Downloading Kubelet config file, if it exists\"\n  # Fetch kubelet config file from GCE metadata server.\n  (\n    umask 077\n    local -r tmp_kubelet_config=\"/tmp/kubelet-config.yaml\"\n    # shellcheck disable=SC2086\n    retry-forever 10 curl ${CURL_FLAGS} \\\n      -H \"X-Google-Metadata-Request: True\" \\\n      -o \"${tmp_kubelet_config}\" \\\n      http://metadata.google.internal/computeMetadata/v1/instance/attributes/kubelet-config\n    # only write to the final location if curl succeeds\n    mv \"${tmp_kubelet_config}\" \"${dest}\"\n  )\n}\n\n# A function to pull kube-master-certs from HMS using hurl\nfunction download-kube-master-certs-hurl {\n  local -r endpoint=$(get-metadata-value \"instance/attributes/gke-api-endpoint\")\n  local -r tmp_kube_master_certs_path=\"/tmp/kube-master-certs.yaml\"\n  local -r kube_master_certs_path=\"${KUBE_HOME}/kube-master-certs\"\n  local -r kube_master_certs_hms_path=$(get-metadata-value \"instance/attributes/kube-master-certs-path\")\n\n  echo \"Downloading kube-master-certs via hurl from ${kube_master_certs_hms_path} to ${tmp_kube_master_certs_path}\"\n  retry-forever 30 ${KUBE_HOME}/bin/hurl --hms_address $endpoint \\\n    --dst \"${tmp_kube_master_certs_path}\" \\\n    \"${kube_master_certs_hms_path}\"\n\n  # Convert the yaml format file into a shell-style file.\n  eval \"$(python3 -c '''\nimport pipes,sys,yaml\nitems = yaml.load(sys.stdin, Loader=yaml.BaseLoader).items()\nfor k, v in items:\n    print(\"readonly {var}={value}\".format(var=k, value=pipes.quote(str(v))))\n''' \u003c \"${tmp_kube_master_certs_path}\" \u003e \"${kube_master_certs_path}\")\"\n\n  # Remove the temp certs and strip perms for other users\n  rm -f \"${tmp_kube_master_certs_path}\"\n  chmod 600 \"${kube_master_certs_path}\"\n}\n\nfunction validate-hash {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n\n  actual_sha1=$(sha1sum \"${file}\" | awk '{ print $1 }') || true\n  actual_sha512=$(sha512sum \"${file}\" | awk '{ print $1 }') || true\n  if [[ \"${actual_sha1}\" != \"${expected}\" ]] \u0026\u0026 [[ \"${actual_sha512}\" != \"${expected}\" ]]; then\n    echo \"== ${file} corrupted, sha1 ${actual_sha1}/sha512 ${actual_sha512} doesn't match expected ${expected} ==\"\n    return 1\n  fi\n}\n\n# Get default service account credentials of the VM.\nGCE_METADATA_INTERNAL=\"http://metadata.google.internal/computeMetadata/v1/instance\"\nfunction get-credentials {\n  # shellcheck disable=SC2086\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/token\" \\\n  | python3 -c 'import sys; import json; print(json.loads(sys.stdin.read())[\"access_token\"])'\n}\n\nfunction valid-storage-scope {\n  # shellcheck disable=SC2086\n  curl ${CURL_FLAGS} \\\n    -H \"Metadata-Flavor: Google\" \\\n    \"${GCE_METADATA_INTERNAL}/service-accounts/default/scopes\" \\\n  | grep -E \"auth/devstorage|auth/cloud-platform\"\n}\n\n# Determine if this node is a master using metadata\nfunction is-master {\n  local -r is_master_val=${KUBERNETES_MASTER:-$(get-metadata-value \"instance/attributes/is-master-node\")}\n  local result=\"false\"\n  if [[ ${is_master_val:-} == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# A function that returns \"true\" if hurl should be used, \"false\" otherwise.\nfunction use-hurl {\n  local -r enable_hms_read=${ENABLE_HMS_READ:-$(get-metadata-value \"instance/attributes/enable_hms_read\")}\n  local result=\"false\"\n\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" \u0026\u0026 \"${enable_hms_read}\" == \"true\" ]]; then\n    result=\"true\"\n  fi\n  echo $result\n}\n\n# Retry a download until we get it. Takes a hash and a set of URLs.\n#\n# $1 is the sha512/sha1 hash of the URL. Can be \"\" if the sha512/sha1 hash is unknown.\n# $2+ are the URLs to download.\nfunction download-or-bust {\n  local -r hash=\"$1\"\n  shift 1\n\n  while true; do\n    for url in \"$@\"; do\n      local file=\"${url##*/}\"\n      rm -f \"${file}\"\n      # if the url belongs to GCS API we should use oauth2_token in the headers if the VM service account has storage scopes\n      local curl_headers=\"\"\n\n      if [[ \"$url\" =~ ^https://storage.googleapis.com.* ]] ; then\n        local canUseCredentials=0\n\n        echo \"Getting the scope of service account configured for VM.\"\n        if ! valid-storage-scope ; then\n          canUseCredentials=1\n          # this behavior is preserved for backward compatibility. We want to fail fast if SA is not available\n          # and try to download without SA if scope does not exist on SA\n          echo \"No service account or service account without storage scope. Attempt to download without service account token.\"\n        fi\n\n        if [[ \"${canUseCredentials}\" == \"0\" ]] ; then\n          echo \"Getting the service account access token configured for VM.\"\n          local access_token=\"\";\n          if access_token=$(get-credentials); then\n            echo \"Service account access token is received. Downloading ${url} using this token.\"\n          else\n            echo \"Cannot get a service account token. Exiting.\"\n            exit 1\n          fi\n\n          curl_headers=${access_token:+Authorization: Bearer \"${access_token}\"}\n        fi\n      fi\n      if ! curl ${curl_headers:+-H \"${curl_headers}\"} -f --ipv4 -Lo \"${file}\" --connect-timeout 20 --retry 6 --retry-delay 10 --retry-connrefused \"${url}\"; then\n        echo \"== Failed to download ${url}. Retrying. ==\"\n      elif [[ -n \"${hash}\" ]] \u0026\u0026 ! validate-hash \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed. Retrying. ==\"\n      else\n        if [[ -n \"${hash}\" ]]; then\n          echo \"== Downloaded ${url} (HASH = ${hash}) ==\"\n        else\n          echo \"== Downloaded ${url} ==\"\n        fi\n        return\n      fi\n    done\n  done\n}\n\nfunction record-preload-info {\n  echo \"$1,$2\" \u003e\u003e \"${KUBE_HOME}/preload_info\"\n}\n\nfunction is-preloaded {\n  local -r key=$1\n  local -r value=$2\n  grep -qs \"${key},${value}\" \"${KUBE_HOME}/preload_info\"\n}\n\nfunction split-commas {\n  echo -e \"${1//,/'\\n'}\"\n}\n\nfunction remount-flexvolume-directory {\n  local -r flexvolume_plugin_dir=$1\n  mkdir -p \"$flexvolume_plugin_dir\"\n  mount --bind \"$flexvolume_plugin_dir\" \"$flexvolume_plugin_dir\"\n  mount -o remount,exec \"$flexvolume_plugin_dir\"\n}\n\nfunction install-gci-mounter-tools {\n  CONTAINERIZED_MOUNTER_HOME=\"${KUBE_HOME}/containerized_mounter\"\n  if [[ -n \"${MOUNTER_ROOTFS_VERSION:-}\" ]]; then\n      local -r mounter_rootfs_version=\"${MOUNTER_ROOTFS_VERSION}\"\n      local -r mounter_rootfs_tar_sha=\"${MOUNTER_ROOTFS_TAR_SHA512}\"\n  else\n    local -r mounter_rootfs_version=\"${DEFAULT_MOUNTER_ROOTFS_VERSION}\"\n    case \"${HOST_PLATFORM}/${HOST_ARCH}\" in\n      linux/amd64)\n        local -r mounter_rootfs_tar_sha=\"${DEFAULT_MOUNTER_ROOTFS_TAR_AMD64_SHA512}\"\n        ;;\n      linux/arm64)\n        local -r mounter_rootfs_tar_sha=\"${DEFAULT_MOUNTER_ROOTFS_TAR_ARM64_SHA512}\"\n        ;;\n      *)\n        echo \"Unrecognized version and platform/arch combination:\"\n        echo \"$mounter_rootfs_version $HOST_PLATFORM/$HOST_ARCH\"\n        echo \"Set MOUNTER_ROOTFS_VERSION and MOUNTER_ROOTFS_TAR_SHA512 to overwrite\"\n        exit 1\n        ;;\n    esac\n  fi\n\n  if is-preloaded \"mounter\" \"${mounter_rootfs_tar_sha}\"; then\n    echo \"mounter is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading gci mounter tools.\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}\"\n\n  # Copy the mounter binary downloaded with the k8s binaries tar file\n  cp \"${KUBE_HOME}/kubernetes/server/bin/mounter\" \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  chmod a+x \"${CONTAINERIZED_MOUNTER_HOME}/mounter\"\n  # Download the debian rootfs required for the mounter container\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  local -r mounter_rootfs_tar=\"containerized-mounter-${mounter_rootfs_version}_${HOST_PLATFORM}_${HOST_ARCH}.tar.gz\"\n  download-or-bust \"${mounter_rootfs_tar_sha}\" \"https://storage.googleapis.com/gke-release/containerized-mounter/${mounter_rootfs_version}/${mounter_rootfs_tar}\"\n  mv \"${KUBE_HOME}/${mounter_rootfs_tar}\" \"/tmp/${mounter_rootfs_tar}\"\n  tar xzf \"/tmp/${mounter_rootfs_tar}\" -C \"${CONTAINERIZED_MOUNTER_HOME}/rootfs\"\n  rm \"/tmp/${mounter_rootfs_tar}\"\n  mkdir -p \"${CONTAINERIZED_MOUNTER_HOME}/rootfs/var/lib/kubelet\"\n\n  record-preload-info \"mounter\" \"${mounter_rootfs_tar_sha}\"\n}\n\n# Install node problem detector binary.\nfunction install-node-problem-detector {\n  if [[ -n \"${NODE_PROBLEM_DETECTOR_VERSION:-}\" ]]; then\n      local -r npd_version=\"${NODE_PROBLEM_DETECTOR_VERSION}\"\n      local -r npd_hash=\"${NODE_PROBLEM_DETECTOR_TAR_HASH}\"\n  else\n      local -r npd_version=\"${DEFAULT_NPD_VERSION}\"\n      case \"${HOST_PLATFORM}/${HOST_ARCH}\" in\n        linux/amd64)\n          local -r npd_hash=\"${DEFAULT_NPD_HASH_AMD64}\"\n          ;;\n        linux/arm64)\n          local -r npd_hash=\"${DEFAULT_NPD_HASH_ARM64}\"\n          ;;\n        # no other architectures are supported currently.\n        # Assumption is that this script only runs on linux,\n        # see cluster/gce/windows/k8s-node-setup.psm1 for windows\n        # https://github.com/kubernetes/node-problem-detector/releases/\n        *)\n          echo \"Unrecognized version and platform/arch combination:\"\n          echo \"$DEFAULT_NPD_VERSION $HOST_PLATFORM/$HOST_ARCH\"\n          echo \"Set NODE_PROBLEM_DETECTOR_VERSION and NODE_PROBLEM_DETECTOR_TAR_HASH to overwrite\"\n          exit 1\n          ;;\n      esac\n  fi\n  local -r npd_tar=\"node-problem-detector-${npd_version}-${HOST_PLATFORM}_${HOST_ARCH}.tar.gz\"\n\n  if is-preloaded \"${npd_tar}\" \"${npd_hash}\"; then\n    echo \"${npd_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading ${npd_tar}.\"\n  local -r npd_release_path=\"${NODE_PROBLEM_DETECTOR_RELEASE_PATH:-https://storage.googleapis.com/gke-release}\"\n  download-or-bust \"${npd_hash}\" \"${npd_release_path}/node-problem-detector/${npd_tar}\"\n  local -r npd_dir=\"${KUBE_HOME}/node-problem-detector\"\n  mkdir -p \"${npd_dir}\"\n  tar xzf \"${KUBE_HOME}/${npd_tar}\" -C \"${npd_dir}\" --overwrite\n  mv \"${npd_dir}/bin\"/* \"${KUBE_BIN}\"\n  chmod a+x \"${KUBE_BIN}/node-problem-detector\"\n  rmdir \"${npd_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${npd_tar}\"\n\n  record-preload-info \"${npd_tar}\" \"${npd_hash}\"\n}\n\nfunction install-cni-binaries {\n  local -r cni_version=${CNI_VERSION:-$DEFAULT_CNI_VERSION}\n  if [[ -n \"${CNI_VERSION:-}\" ]]; then\n      local -r cni_hash=\"${CNI_HASH:-}\"\n  else\n      local -r cni_hash=\"${DEFAULT_CNI_HASH}\"\n  fi\n\n  local -r cni_tar=\"${CNI_TAR_PREFIX}${cni_version}.tgz\"\n  local -r cni_url=\"${CNI_STORAGE_URL_BASE}/${cni_version}/${cni_tar}\"\n\n  if is-preloaded \"${cni_tar}\" \"${cni_hash}\"; then\n    echo \"${cni_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading cni binaries\"\n  download-or-bust \"${cni_hash}\" \"${cni_url}\"\n  local -r cni_dir=\"${KUBE_HOME}/cni\"\n  mkdir -p \"${cni_dir}/bin\"\n  tar xzf \"${KUBE_HOME}/${cni_tar}\" -C \"${cni_dir}/bin\" --overwrite\n  mv \"${cni_dir}/bin\"/* \"${KUBE_BIN}\"\n  rmdir \"${cni_dir}/bin\"\n  rm -f \"${KUBE_HOME}/${cni_tar}\"\n\n  record-preload-info \"${cni_tar}\" \"${cni_hash}\"\n}\n\n# Install crictl binary.\n# Assumptions: HOST_PLATFORM and HOST_ARCH are specified by calling detect_host_info.\nfunction install-crictl {\n  if [[ -n \"${CRICTL_VERSION:-}\" ]]; then\n    local -r crictl_version=\"${CRICTL_VERSION}\"\n    local -r crictl_hash=\"${CRICTL_TAR_HASH}\"\n  else\n    local -r crictl_version=\"${DEFAULT_CRICTL_VERSION}\"\n    case \"${HOST_PLATFORM}/${HOST_ARCH}\" in\n      linux/amd64)\n        local -r crictl_hash=\"${DEFAULT_CRICTL_AMD64_SHA512}\"\n        ;;\n      linux/arm64)\n        local -r crictl_hash=\"${DEFAULT_CRICTL_ARM64_SHA512}\"\n        ;;\n      *)\n        echo \"Unrecognized version and platform/arch combination:\"\n        echo \"$DEFAULT_CRICTL_VERSION $HOST_PLATFORM/$HOST_ARCH\"\n        echo \"Set CRICTL_VERSION and CRICTL_TAR_HASH to overwrite\"\n        exit 1\n    esac\n  fi\n  local -r crictl=\"crictl-${crictl_version}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\"\n\n  # Create crictl config file.\n  cat \u003e /etc/crictl.yaml \u003c\u003cEOF\nruntime-endpoint: ${CONTAINER_RUNTIME_ENDPOINT:-unix:///var/run/dockershim.sock}\nEOF\n\n  if is-preloaded \"${crictl}\" \"${crictl_hash}\"; then\n    echo \"crictl is preloaded\"\n    return\n  fi\n\n  echo \"Downloading crictl\"\n  local -r crictl_path=\"https://storage.googleapis.com/gke-release/cri-tools/${crictl_version}\"\n  download-or-bust \"${crictl_hash}\" \"${crictl_path}/${crictl}\"\n  tar xf \"${crictl}\"\n  mv crictl \"${KUBE_BIN}/crictl\"\n  rm -f \"${crictl}\"\n\n  record-preload-info \"${crictl}\" \"${crictl_hash}\"\n}\n\nfunction preload-pause-image {\n  if is-preloaded \"pause\" \"${GKE_CONTAINERD_INFRA_CONTAINER}\"; then\n    echo \"pause image is preloaded\"\n    return\n  fi\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    # Preload with no credential when runtime is docker because docker needs\n    # special login setup.\n    docker pull ${GKE_CONTAINERD_INFRA_CONTAINER}\n  else\n    # preloading pause image. It will be used in preloader and will be\n    # useful for staging builds where access_token is needed to pull the image\n    local access_token=\"\";\n\n    if access_token=$(get-credentials); then\n      \"${KUBE_BIN}/crictl\" pull --creds \"oauth2accesstoken:${access_token}\" ${GKE_CONTAINERD_INFRA_CONTAINER}\n    else\n      echo \"No access token. Pulling without it.\"\n      \"${KUBE_BIN}/crictl\" pull ${GKE_CONTAINERD_INFRA_CONTAINER}\n    fi\n  fi\n  record-preload-info \"pause\" \"${GKE_CONTAINERD_INFRA_CONTAINER}\"\n}\n\nfunction install-exec-auth-plugin {\n  if [[ ! \"${EXEC_AUTH_PLUGIN_URL:-}\" ]]; then\n      return\n  fi\n  local -r plugin_url=\"${EXEC_AUTH_PLUGIN_URL}\"\n  local -r plugin_hash=\"${EXEC_AUTH_PLUGIN_HASH}\"\n\n  if is-preloaded \"gke-exec-auth-plugin\" \"${plugin_hash}\"; then\n    echo \"gke-exec-auth-plugin is preloaded\"\n    return\n  fi\n\n  echo \"Downloading gke-exec-auth-plugin binary\"\n  download-or-bust \"${plugin_hash}\" \"${plugin_url}\"\n  mv \"${KUBE_HOME}/gke-exec-auth-plugin\" \"${KUBE_BIN}/gke-exec-auth-plugin\"\n  chmod a+x \"${KUBE_BIN}/gke-exec-auth-plugin\"\n\n  if [[ ! \"${EXEC_AUTH_PLUGIN_LICENSE_URL:-}\" ]]; then\n      return\n  fi\n  local -r license_url=\"${EXEC_AUTH_PLUGIN_LICENSE_URL}\"\n  echo \"Downloading gke-exec-auth-plugin license\"\n  download-or-bust \"\" \"${license_url}\"\n  mv \"${KUBE_HOME}/LICENSE\" \"${KUBE_BIN}/gke-exec-auth-plugin-license\"\n\n  record-preload-info \"gke-exec-auth-plugin\" \"${plugin_hash}\"\n}\n\nfunction install-kube-manifests {\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  local dst_dir=\"${KUBE_HOME}/kube-manifests\"\n  mkdir -p \"${dst_dir}\"\n  local manifests_tar_urls\n  while IFS= read -r url; do\n    manifests_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${KUBE_MANIFESTS_TAR_URL}\")\n  local -r manifests_tar=\"${manifests_tar_urls[0]##*/}\"\n  if [ -n \"${KUBE_MANIFESTS_TAR_HASH:-}\" ]; then\n    local -r manifests_tar_hash=\"${KUBE_MANIFESTS_TAR_HASH}\"\n  else\n    echo \"Downloading k8s manifests hash (not found in env)\"\n    download-or-bust \"\" \"${manifests_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r manifests_tar_hash=$(cat \"${manifests_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${manifests_tar}\" \"${manifests_tar_hash}\"; then\n    echo \"${manifests_tar} is preloaded.\"\n    return\n  fi\n\n  echo \"Downloading k8s manifests tar\"\n  download-or-bust \"${manifests_tar_hash}\" \"${manifests_tar_urls[@]}\"\n  tar xzf \"${KUBE_HOME}/${manifests_tar}\" -C \"${dst_dir}\" --overwrite\n  local -r kube_addon_registry=\"${KUBE_ADDON_REGISTRY:-k8s.gcr.io}\"\n  if [[ \"${kube_addon_registry}\" != \"k8s.gcr.io\" ]]; then\n    find \"${dst_dir}\" \\(-name '*.yaml' -or -name '*.yaml.in'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image:\\s.*)k8s.gcr.io@\\1${kube_addon_registry}@\"\n    find \"${dst_dir}\" \\(-name '*.manifest' -or -name '*.json'\\) -print0 | \\\n      xargs -0 sed -ri \"s@(image\\\":\\s+\\\")k8s.gcr.io@\\1${kube_addon_registry}@\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/gci-configure-helper.sh\" \"${KUBE_BIN}/configure-helper.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/configure-kubeapiserver.sh\" \"${KUBE_BIN}/configure-kubeapiserver.sh\"\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/gke-internal-configure-helper.sh\" \"${KUBE_BIN}/\"\n  fi\n  if [[ -e \"${dst_dir}/kubernetes/gci-trusty/node-registration-checker.sh\" ]]; then\n    cp \"${dst_dir}/kubernetes/gci-trusty/node-registration-checker.sh\" \"${KUBE_BIN}/\"\n  fi\n  cp \"${dst_dir}/kubernetes/gci-trusty/health-monitor.sh\" \"${KUBE_BIN}/health-monitor.sh\"\n  cp \"${dst_dir}/kubernetes/gci-trusty/networkd-monitor.sh\" \"${KUBE_BIN}/networkd-monitor.sh\"\n\n  rm -f \"${KUBE_HOME}/${manifests_tar}\"\n  rm -f \"${KUBE_HOME}/${manifests_tar}.sha512\"\n\n  record-preload-info \"${manifests_tar}\" \"${manifests_tar_hash}\"\n}\n\n# Installs hurl to ${KUBE_HOME}/bin/hurl if not already installed.\nfunction install-hurl {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/hurl\" ]]; then\n    echo \"install-hurl: hurl already installed\"\n    return\n  fi\n\n  local -r hurl_gcs_att=\"instance/attributes/hurl-gcs-url\"\n  local -r hurl_gcs_url=${HURL_GCS_URL:-$(get-metadata-value \"${hurl_gcs_att}\")}\n\n  if [[ -z \"${hurl_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-hurl: Unable to find GCE metadata ${hurl_gcs_att}\"\n    return\n  fi\n\n  # Download hurl binary from a GCS bucket.\n  local -r hurl_bin=\"hurl\"\n  echo \"install-hurl: Installing hurl from ${hurl_gcs_url} ... \"\n  download-or-bust \"\" \"${hurl_gcs_url}\"\n  if [[ -f \"${KUBE_HOME}/${hurl_bin}\" ]]; then\n    chmod a+x ${KUBE_HOME}/${hurl_bin}\n    mv \"${KUBE_HOME}/${hurl_bin}\" \"${KUBE_BIN}/${hurl_bin}\"\n    echo \"install-hurl: hurl installed to ${KUBE_BIN}/${hurl_bin}\"\n    return\n  fi\n}\n\n# Installs inplace to ${KUBE_HOME}/bin/inplace if not already installed.\nfunction install-inplace {\n  cd \"${KUBE_HOME}\"\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"install-inplace: inplace already installed\"\n    return\n  fi\n  local -r inplace_gcs_att=\"instance/attributes/inplace-gcs-url\"\n  local -r inplace_gcs_url=${INPLACE_GCS_URL:-$(get-metadata-value \"${inplace_gcs_att}\")}\n  if [[ -z \"${inplace_gcs_url}\" ]]; then\n    # URL not present in GCE Instance Metadata\n    echo \"install-inplace: Unable to find GCE metadata ${inplace_gcs_att}\"\n    return\n  fi\n  echo \"install-inplace: Installing inplace from ${inplace_gcs_url} ...\"\n  download-or-bust \"\" \"${inplace_gcs_url}\"\n  local -r inplace_bin=\"inplace\"\n  if [[ -f \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n    mv \"${KUBE_HOME}/${inplace_bin}\" \"${KUBE_BIN}/${inplace_bin}\"\n    if [[ ! -d \"${KUBE_HOME}/${inplace_bin}\" ]]; then\n      mkdir -p \"${KUBE_HOME}/${inplace_bin}\"\n    fi\n    cat \u003e \"${KUBE_HOME}/${inplace_bin}/inplace.hash\" \u003c\u003cEOF\n${inplace_gcs_url}\nEOF\n    echo \"install-inplace: inplace installed to ${KUBE_BIN}/${inplace_bin}\"\n    return\n  fi\n}\n\n# A function to download in-place component manifests if in-place agent is\n# present.\nfunction inplace-run-once {\n  if [[ -f \"${KUBE_HOME}/bin/inplace\" ]]; then\n    echo \"inplace-run-once: using inplace to download inplace component manefists\"\n    local dst_dir=\"${KUBE_HOME}/kube-manifests/kubernetes/gci-trusty\"\n    mkdir -p \"${dst_dir}/in-place\"\n    mkdir -p \"${dst_dir}/gce-extras/in-place\"\n    ${KUBE_HOME}/bin/inplace --mode=run-once --in_place_addon_path=\"${dst_dir}/gce-extras/in-place\" --master_pod_path=\"${dst_dir}/in-place\"\n  fi\n}\n\nfunction install-auger {\n  echo \"Downloading auger binary\"\n  if [[ -f \"${KUBE_HOME}/bin/auger\" ]]; then\n    echo \"auger is already installed\"\n    return\n  fi\n  AUGER_STORE_PATH=\"${AUGER_STORE_PATH:-https://storage.googleapis.com/gke-release-staging/auger}\"\n  AUGER_VERSION=\"${AUGER_VERSION:-v1.0.0-gke.1}\"\n  download-or-bust \"\" \"${AUGER_STORE_PATH}/${AUGER_VERSION}/auger.sha1\"\n  sha1=\"$(cat auger.sha1)\"\n  readonly sha1 # Declare readonly separately to avoid masking error values.\n  rm -f \"auger.sha1\"\n  download-or-bust \"${sha1}\" \"${AUGER_STORE_PATH}/${AUGER_VERSION}/auger\"\n  mv \"${KUBE_HOME}/auger\" \"${KUBE_HOME}/bin/auger\"\n  chmod a+x \"${KUBE_HOME}/bin/auger\"\n  record-preload-info \"auger\" \"${sha1}\"\n}\n\n# Extract etcdctl binary from etcd image.\nfunction install-etcdctl {\n  echo \"Installing etcdctl binary\"\n  if [[ -f \"${KUBE_HOME}/bin/etcdctl\" ]]; then\n    echo \"etcdctl is already installed\"\n    return\n  fi\n  local -r etcd_image=\"gcr.io/gke-master-images/etcd:${ETCDCTL_VERSION}\"\n  container_id=\"$(docker create \"${etcd_image}\" sh)\"\n  readonly containerId\n  docker cp \"${container_id}:usr/local/bin/etcdctl\" \"${KUBE_HOME}/bin/etcdctl\"\n  chmod a+x \"${KUBE_HOME}/bin/etcdctl\"\n  docker rm \"${container_id}\"\n  docker rmi \"${etcd_image}\"\n}\n\nfunction install-gcfsd {\n  echo \"Downloading Riptide FUSE client\"\n  if is-preloaded \"gcfsd\" \"${RIPTIDE_FUSE_VERSION}\"; then\n    echo \"gcfsd is preloaded.\"\n    return\n  fi\n\n  if [[ \"${HOST_ARCH}\" == \"arm64\" ]]; then\n    RIPTIDE_FUSE_STORE_PATH=\"https://storage.googleapis.com/${RIPTIDE_FUSE_BUCKET}/gcfsd/${RIPTIDE_FUSE_VERSION}/arm64\"\n  else\n    RIPTIDE_FUSE_STORE_PATH=\"https://storage.googleapis.com/${RIPTIDE_FUSE_BUCKET}/gcfsd/${RIPTIDE_FUSE_VERSION}\"\n  fi\n\n  if [[ \"${RIPTIDE_FUSE_VERSION}\" \u003e v0.19.0 ]] \u0026\u0026 [[ \"${RIPTIDE_FUSE_VERSION}\" != v0.4.0 ]] ; then\n    download-or-bust \"\" \"${RIPTIDE_FUSE_STORE_PATH}/gcfsd.tar.gz\"\n  fi\n  download-or-bust \"\" \"${RIPTIDE_FUSE_STORE_PATH}/gcfsd\"\n  mv \"${KUBE_HOME}/gcfsd\" \"${KUBE_HOME}/bin/gcfsd\"\n  chmod a+x \"${KUBE_HOME}/bin/gcfsd\"\n  record-preload-info \"gcfsd\" \"${RIPTIDE_FUSE_VERSION}\"\n}\n\nfunction install-riptide-snapshotter {\n  echo \"Downloading Riptide snapshotter\"\n  if is-preloaded \"containerd-gcfs-grpc\" \"${RIPTIDE_SNAPSHOTTER_VERSION}\"; then\n    echo \"containerd-gcfs-grpc is preloaded.\"\n    return\n  fi\n  RIPTIDE_SNAPSHOTTER_STORE_PATH=\"https://storage.googleapis.com/${RIPTIDE_SNAPSHOTTER_BUCKET}/gcfs-snapshotter/${RIPTIDE_SNAPSHOTTER_VERSION}\"\n  if [[ \"${RIPTIDE_SNAPSHOTTER_VERSION}\" \u003e v1.4-2 ]]; then\n    download-or-bust \"\" \"${RIPTIDE_SNAPSHOTTER_STORE_PATH}/containerd-gcfs-grpc.tar.gz\"\n  fi\n\n  if [[ \"${HOST_ARCH}\" == \"arm64\" ]]; then\n    RIPTIDE_SNAPSHOTTER_BINARY=\"containerd-gcfs-grpc-arm64\"\n  else\n    RIPTIDE_SNAPSHOTTER_BINARY=\"containerd-gcfs-grpc\"\n  fi\n\n  download-or-bust \"\" \"${RIPTIDE_SNAPSHOTTER_STORE_PATH}/${RIPTIDE_SNAPSHOTTER_BINARY}\"\n  mv \"${KUBE_HOME}/${RIPTIDE_SNAPSHOTTER_BINARY}\" \"${KUBE_HOME}/bin/containerd-gcfs-grpc\"\n  chmod a+x \"${KUBE_HOME}/bin/containerd-gcfs-grpc\"\n  record-preload-info \"containerd-gcfs-grpc\" \"${RIPTIDE_SNAPSHOTTER_VERSION}\"\n}\n\n# Install Riptide FUSE client and Riptide snapshotter\nfunction install-riptide {\n  install-gcfsd\n  install-riptide-snapshotter\n}\n\nfunction configure-cgroup-mode {\n  if which cgroup_helper \u003e /dev/null 2\u003e\u00261; then\n    if [[ \"${CGROUP_MODE:-}\" == \"v1\" ]] \u0026\u0026 cgroup_helper show | grep -q 'unified'; then\n      cgroup_helper set hybrid\n      echo \"set cgroup config to hybrid, now rebooting...\"\n      reboot\n    elif [[ \"${CGROUP_MODE:-}\" == \"v2\" ]] \u0026\u0026 cgroup_helper show | grep -q 'hybrid'; then\n      cgroup_helper set unified\n      echo \"set cgroup config to unified, now rebooting...\"\n      reboot\n    fi\n  fi\n}\n\n# A helper function for loading a docker image. It keeps trying up to 5 times.\n#\n# $1: Full path of the docker image\nfunction try-load-docker-image {\n  local -r img=$1\n  echo \"Try to load docker image file ${img}\"\n  # Temporarily turn off errexit, because we don't want to exit on first failure.\n  set +e\n  local -r max_attempts=5\n  local -i attempt_num=1\n\n  if [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"docker\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-docker load -i}\n  elif [[ \"${CONTAINER_RUNTIME_NAME:-}\" == \"containerd\" || \"${CONTAINERD_TEST:-}\"  == \"containerd\" ]]; then\n    load_image_command=${LOAD_IMAGE_COMMAND:-ctr -n=k8s.io images import}\n  else\n    load_image_command=\"${LOAD_IMAGE_COMMAND:-}\"\n  fi\n\n  # Deliberately word split load_image_command\n  # shellcheck disable=SC2086\n  until timeout 30 ${load_image_command} \"${img}\"; do\n    if [[ \"${attempt_num}\" == \"${max_attempts}\" ]]; then\n      echo \"Fail to load docker image file ${img} using ${load_image_command} after ${max_attempts} retries. Exit!!\"\n      exit 1\n    else\n      attempt_num=$((attempt_num+1))\n      sleep 5\n    fi\n  done\n  # Re-enable errexit.\n  set -e\n}\n\n# Loads kube-system docker images. It is better to do it before starting kubelet,\n# as kubelet will restart docker daemon, which may interfere with loading images.\nfunction load-docker-images {\n  echo \"Start loading kube-system docker images\"\n  local -r img_dir=\"${KUBE_HOME}/kube-docker-files\"\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    try-load-docker-image \"${img_dir}/kube-apiserver.tar\"\n    try-load-docker-image \"${img_dir}/kube-controller-manager.tar\"\n    try-load-docker-image \"${img_dir}/kube-scheduler.tar\"\n  else\n    try-load-docker-image \"${img_dir}/kube-proxy.tar\"\n  fi\n}\n\n# If we are on ubuntu we can try to install docker\nfunction install-docker {\n  # bailout if we are not on ubuntu\n  if ! command -v apt-get \u003e/dev/null 2\u003e\u00261; then\n    echo \"Unable to automatically install docker. Bailing out...\"\n    return\n  fi\n  # Install Docker deps, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository\n  # shellcheck disable=SC2086\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install Docker\n  apt-get update \u0026\u0026 \\\n    apt-get install -y --no-install-recommends \"${GCI_DOCKER_VERSION:-\"docker-ce=5:19.03.*\"}\"\n  rm -rf /var/lib/apt/lists/*\n}\n\n# If we are on ubuntu we can try to install containerd\nfunction install-containerd-ubuntu {\n  # bailout if we are not on ubuntu\n  if [[ -z \"$(command -v lsb_release)\" || $(lsb_release -si) != \"Ubuntu\" ]]; then\n    echo \"Unable to automatically install containerd in non-ubuntu image. Bailing out...\"\n    exit 2\n  fi\n\n  # Install dependencies, some of these are already installed in the image but\n  # that's fine since they won't re-install and we can reuse the code below\n  # for another image someday.\n  apt-get update\n  apt-get install -y --no-install-recommends \\\n    apt-transport-https \\\n    ca-certificates \\\n    socat \\\n    curl \\\n    gnupg2 \\\n    software-properties-common \\\n    lsb-release\n\n  release=$(lsb_release -cs)\n\n  # Add the Docker apt-repository (as we install containerd from there)\n  # shellcheck disable=SC2086\n  curl ${CURL_FLAGS} \\\n    --location \\\n    \"https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\")/gpg\" \\\n  | apt-key add -\n  add-apt-repository \\\n    \"deb [arch=${HOST_ARCH}] https://download.docker.com/${HOST_PLATFORM}/$(. /etc/os-release; echo \"$ID\") \\\n    $release stable\"\n\n  # Install containerd from Docker repo\n  apt-get update \u0026\u0026 \\\n    apt-get install -y --no-install-recommends containerd\n  rm -rf /var/lib/apt/lists/*\n\n  # Override to latest versions of containerd and runc\n  systemctl stop containerd\n  if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" ]]; then\n    # TODO(https://github.com/containerd/containerd/issues/2901): Remove this check once containerd has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install containerd in non-amd64 image. Bailing out...\"\n      exit 2\n    fi\n    # containerd versions have slightly different url(s), so try both\n    # shellcheck disable=SC2086\n    ( curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}-${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" \\\n      || curl ${CURL_FLAGS} \\\n        --location \\\n        \"https://github.com/containerd/containerd/releases/download/${UBUNTU_INSTALL_CONTAINERD_VERSION}/containerd-${UBUNTU_INSTALL_CONTAINERD_VERSION:1}.${HOST_PLATFORM}-${HOST_ARCH}.tar.gz\" ) \\\n    | tar --overwrite -xzv -C /usr/\n  fi\n  if [[ -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n    # TODO: Remove this check once runc has arm64 release.\n    if [[ $(dpkg --print-architecture) != \"amd64\" ]]; then\n      echo \"Unable to automatically install runc in non-amd64. Bailing out...\"\n      exit 2\n    fi\n    # shellcheck disable=SC2086\n    curl ${CURL_FLAGS} \\\n      --location \\\n      \"https://github.com/opencontainers/runc/releases/download/${UBUNTU_INSTALL_RUNC_VERSION}/runc.${HOST_ARCH}\" --output /usr/sbin/runc \\\n    \u0026\u0026 chmod 755 /usr/sbin/runc\n  fi\n  sudo systemctl start containerd\n}\n\nfunction ensure-container-runtime {\n  container_runtime=\"${CONTAINER_RUNTIME:-docker}\"\n  if [[ \"${container_runtime}\" == \"docker\" ]]; then\n    if ! command -v docker \u003e/dev/null 2\u003e\u00261; then\n      install-docker\n      if ! command -v docker \u003e/dev/null 2\u003e\u00261; then\n        echo \"ERROR docker not found. Aborting.\"\n        exit 2\n      fi\n    fi\n    docker version\n  elif [[ \"${container_runtime}\" == \"containerd\" ]]; then\n    # Install containerd/runc if requested\n    if [[ -n \"${UBUNTU_INSTALL_CONTAINERD_VERSION:-}\" || -n \"${UBUNTU_INSTALL_RUNC_VERSION:-}\" ]]; then\n      install-containerd-ubuntu\n    fi\n    # Verify presence and print versions of ctr, containerd, runc\n    if ! command -v ctr \u003e/dev/null 2\u003e\u00261; then\n      echo \"ERROR ctr not found. Aborting.\"\n      exit 2\n    fi\n    ctr --version\n\n    if ! command -v containerd \u003e/dev/null 2\u003e\u00261; then\n      echo \"ERROR containerd not found. Aborting.\"\n      exit 2\n    fi\n    containerd --version\n\n    if ! command -v runc \u003e/dev/null 2\u003e\u00261; then\n      echo \"ERROR runc not found. Aborting.\"\n      exit 2\n    fi\n    runc --version\n  fi\n}\n\n# Downloads kubernetes binaries and kube-system manifest tarball, unpacks them,\n# and places them into suitable directories. Files are placed in /home/kubernetes.\nfunction install-kube-binary-config {\n  cd \"${KUBE_HOME}\"\n  local server_binary_tar_urls\n  while IFS= read -r url; do\n    server_binary_tar_urls+=(\"$url\")\n  done \u003c \u003c(split-commas \"${SERVER_BINARY_TAR_URL}\")\n  local -r server_binary_tar=\"${server_binary_tar_urls[0]##*/}\"\n  if [[ -n \"${SERVER_BINARY_TAR_HASH:-}\" ]]; then\n    local -r server_binary_tar_hash=\"${SERVER_BINARY_TAR_HASH}\"\n  else\n    echo \"Downloading binary release sha512 (not found in env)\"\n    download-or-bust \"\" \"${server_binary_tar_urls[@]/.tar.gz/.tar.gz.sha512}\"\n    local -r server_binary_tar_hash=$(cat \"${server_binary_tar}.sha512\")\n  fi\n\n  if is-preloaded \"${server_binary_tar}\" \"${server_binary_tar_hash}\"; then\n    echo \"${server_binary_tar} is preloaded.\"\n  else\n    echo \"Downloading binary release tar\"\n    download-or-bust \"${server_binary_tar_hash}\" \"${server_binary_tar_urls[@]}\"\n    tar xzf \"${KUBE_HOME}/${server_binary_tar}\" -C \"${KUBE_HOME}\" --overwrite\n    # Copy docker_tag and image files to ${KUBE_HOME}/kube-docker-files.\n    local -r src_dir=\"${KUBE_HOME}/kubernetes/server/bin\"\n    local dst_dir=\"${KUBE_HOME}/kube-docker-files\"\n    mkdir -p \"${dst_dir}\"\n    cp \"${src_dir}/\"*.docker_tag \"${dst_dir}\"\n    if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]]; then\n      cp \"${src_dir}/kube-proxy.tar\" \"${dst_dir}\"\n    else\n      cp \"${src_dir}/kube-apiserver.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-controller-manager.tar\" \"${dst_dir}\"\n      cp \"${src_dir}/kube-scheduler.tar\" \"${dst_dir}\"\n      cp -r \"${KUBE_HOME}/kubernetes/addons\" \"${dst_dir}\"\n    fi\n    load-docker-images\n    mv \"${src_dir}/kubelet\" \"${KUBE_BIN}\"\n    mv \"${src_dir}/kubectl\" \"${KUBE_BIN}\"\n\n    # Some older images have LICENSES baked-in as a file. Presumably they will\n    # have the directory baked-in eventually.\n    rm -rf \"${KUBE_HOME}\"/LICENSES\n    mv \"${KUBE_HOME}/kubernetes/LICENSES\" \"${KUBE_HOME}\"\n    mv \"${KUBE_HOME}/kubernetes/kubernetes-src.tar.gz\" \"${KUBE_HOME}\"\n\n    record-preload-info \"${server_binary_tar}\" \"${server_binary_tar_hash}\"\n  fi\n\n  if [[ \"${NETWORK_PROVIDER:-}\" == \"kubenet\" ]] || \\\n     [[ \"${NETWORK_PROVIDER:-}\" == \"cni\" ]]; then\n    install-cni-binaries\n  fi\n\n  # Put kube-system pods manifests in ${KUBE_HOME}/kube-manifests/.\n  install-kube-manifests\n  chmod -R 755 \"${KUBE_BIN}\"\n\n  # Install gci mounter related artifacts to allow mounting storage volumes in GCI\n  install-gci-mounter-tools\n\n  # Remount the Flexvolume directory with the \"exec\" option, if needed.\n  if [[ \"${REMOUNT_VOLUME_PLUGIN_DIR:-}\" == \"true\" \u0026\u0026 -n \"${VOLUME_PLUGIN_DIR:-}\" ]]; then\n    remount-flexvolume-directory \"${VOLUME_PLUGIN_DIR}\"\n  fi\n\n  # Install crictl on each node.\n  install-crictl\n\n  # Preload pause image\n  preload-pause-image\n\n  # Copy health check binaries to a tmpfs mount to reduce block IO usage.\n  setup-shm-healthcheck-binaries\n\n  # TODO(awly): include the binary and license in the OS image.\n  install-exec-auth-plugin\n\n  # Source GKE specific scripts.\n  #\n  # This must be done after install-kube-manifests where the\n  # gke-internal-configure.sh is downloaded.\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    echo \"Running GKE internal configuration script gke-internal-configure.sh\"\n    . \"${KUBE_HOME}/bin/gke-internal-configure.sh\"\n  fi\n\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"false\" ]] \u0026\u0026 \\\n     [[ \"${ENABLE_NODE_PROBLEM_DETECTOR:-}\" == \"standalone\" ]]; then\n    install-node-problem-detector\n    if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n      install-npd-custom-plugins\n    fi\n  fi\n\n  # Clean up.\n  rm -rf \"${KUBE_HOME}/kubernetes\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}\"\n  rm -f \"${KUBE_HOME}/${server_binary_tar}.sha512\"\n}\n\nfunction setup-shm-healthcheck-binaries() {\n  if [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n    return\n  fi\n  if [[ \"${ENABLE_SHM_HEALTHCHECK_BINARIES:-}\" != \"true\" ]];then\n    return\n  fi\n\n  local -r shm_dir=\"${HEALTHCHECK_SHM_DIR:-/dev/kube_shm}\"\n  local -r shm_bin_dir=\"${shm_dir}/bin\"\n\n  mkdir -p \"$shm_dir\"\n  mount -t tmpfs -o exec none \"$shm_dir\"\n  mkdir \"${shm_bin_dir}\"\n\n  cp -f \"${KUBE_BIN}/crictl\" \"${shm_bin_dir}/crictl\"\n  cp -f \"$(which curl)\" \"${shm_bin_dir}/curl\"\n}\n\nfunction install-extra-node-requirements() {\n  if [[ \"${KUBERNETES_MASTER:-}\" != \"false\" ]]; then\n    return\n  fi\n  if [[ -e \"${KUBE_HOME}/bin/gke-internal-configure.sh\" ]]; then\n    # M4A is not relevant on ARM\n    if [[ \"${HOST_ARCH}\" == \"amd64\" ]]; then\n      install-m4a-apparmor-profile\n    fi\n  fi\n}\n\n# This function detects the platform/arch of the machine where the script runs,\n# and sets the HOST_PLATFORM and HOST_ARCH environment variables accordingly.\n# Callers can specify HOST_PLATFORM_OVERRIDE and HOST_ARCH_OVERRIDE to skip the detection.\n# This function is adapted from the detect_client_info function in cluster/get-kube-binaries.sh\n# and kube::util::host_os, kube::util::host_arch functions in hack/lib/util.sh\n# This function should be synced with detect_host_info in ./configure-helper.sh\nfunction detect_host_info() {\n  HOST_PLATFORM=${HOST_PLATFORM_OVERRIDE:-\"$(uname -s)\"}\n  case \"${HOST_PLATFORM}\" in\n    Linux|linux)\n      HOST_PLATFORM=\"linux\"\n      ;;\n    *)\n      echo \"Unknown, unsupported platform: ${HOST_PLATFORM}.\" \u003e\u00262\n      echo \"Supported platform(s): linux.\" \u003e\u00262\n      echo \"Bailing out.\" \u003e\u00262\n      exit 2\n  esac\n\n  HOST_ARCH=${HOST_ARCH_OVERRIDE:-\"$(uname -m)\"}\n  case \"${HOST_ARCH}\" in\n    x86_64*|i?86_64*|amd64*)\n      HOST_ARCH=\"amd64\"\n      ;;\n    aHOST_arch64*|aarch64*|arm64*)\n      HOST_ARCH=\"arm64\"\n      ;;\n    *)\n      echo \"Unknown, unsupported architecture (${HOST_ARCH}).\" \u003e\u00262\n      echo \"Supported architecture(s): amd64 and arm64.\" \u003e\u00262\n      echo \"Bailing out.\" \u003e\u00262\n      exit 2\n      ;;\n  esac\n}\n\n# Retries a command forever with a delay between retries.\n# Args:\n#  $1    : delay between retries, in seconds.\n#  $2... : the command to run.\nfunction retry-forever {\n  local -r delay=\"$1\"\n  shift 1\n\n  until \"$@\"; do\n    echo \"== $* failed, retrying after ${delay}s\"\n    sleep \"${delay}\"\n  done\n}\n\n# Initializes variables used by the log-* functions.\n#\n# get-metadata-value must be defined before calling this function.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-init {\n  # Used by log-* functions.\n  LOG_CLUSTER_ID=${LOG_CLUSTER_ID:-$(get-metadata-value 'instance/attributes/cluster-uid' 'get-metadata-value-error')}\n  LOG_INSTANCE_NAME=$(hostname || echo 'hostname-error')\n  LOG_BOOT_ID=$(journalctl --list-boots | grep -E '^ *0' | awk '{print $2}' || echo 'journalctl-error')\n  declare -Ag LOG_START_TIMES\n  declare -ag LOG_TRAP_STACK\n\n  LOG_STATUS_STARTED='STARTED'\n  LOG_STATUS_COMPLETED='COMPLETED'\n  LOG_STATUS_ERROR='ERROR'\n}\n\n# Sets an EXIT trap.\n# Args:\n#   $1:... : the trap command.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-push {\n  local t=\"${*:1}\"\n  LOG_TRAP_STACK+=(\"${t}\")\n  # shellcheck disable=2064\n  trap \"${t}\" EXIT\n}\n\n# Removes and restores an EXIT trap.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-trap-pop {\n  # Remove current trap.\n  unset 'LOG_TRAP_STACK[-1]'\n\n  # Restore previous trap.\n  if [ ${#LOG_TRAP_STACK[@]} -ne 0 ]; then\n    local t=\"${LOG_TRAP_STACK[-1]}\"\n    # shellcheck disable=2064\n    trap \"${t}\" EXIT\n  else\n    # If no traps in stack, clear.\n    trap EXIT\n  fi\n}\n\n# Logs the end of a bootstrap step that errored.\n# Args:\n#  $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-error {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_ERROR}\" \"encountered non-zero exit code\"\n}\n\n# Wraps a command with bootstrap logging.\n# Args:\n#   $1    : bootstrap step name.\n#   $2... : the command to run.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-wrap {\n  local bootstep=\"$1\"\n  local command=\"${*:2}\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n  $command\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Logs a bootstrap step start. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-start {\n  local bootstep=\"$1\"\n\n  log-trap-push \"log-error ${bootstep}\"\n  log-proto \"${bootstep}\" \"${LOG_STATUS_STARTED}\"\n}\n\n# Logs a bootstrap step end. Prefer log-wrap.\n# Args:\n#   $1 : bootstrap step name.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-end {\n  local bootstep=\"$1\"\n\n  log-proto \"${bootstep}\" \"${LOG_STATUS_COMPLETED}\"\n  log-trap-pop\n}\n\n# Writes a log proto to stdout.\n# Args:\n#   $1: bootstrap step name.\n#   $2: status. Either 'STARTED', 'COMPLETED', or 'ERROR'.\n#   $3: optional status reason.\n#\n# NOTE: this function is duplicated in configure-helper.sh, any changes here\n# should be duplicated there as well.\nfunction log-proto {\n  local bootstep=\"$1\"\n  local status=\"$2\"\n  local status_reason=\"${3:-}\"\n\n  # Get current time.\n  local current_time\n  current_time=\"$(date --utc '+%s.%N')\"\n  # ...formatted as UTC RFC 3339.\n  local timestamp\n  timestamp=\"$(date --utc --date=\"@${current_time}\" '+%FT%T.%NZ')\"\n\n  # Calculate latency.\n  local latency='null'\n  if [ \"${status}\" == \"${LOG_STATUS_STARTED}\" ]; then\n    LOG_START_TIMES[\"${bootstep}\"]=\"${current_time}\"\n  else\n    local start_time=\"${LOG_START_TIMES[\"${bootstep}\"]}\"\n    unset 'LOG_START_TIMES['\"${bootstep}\"']'\n\n    # Bash cannot do non-integer math, shell out to awk.\n    latency=\"$(echo \"${current_time} ${start_time}\" | awk '{print $1 - $2}')s\"\n\n    # The default latency is null which cannot be wrapped as a string so we must\n    # do it here instead of the printf.\n    latency=\"\\\"${latency}\\\"\"\n  fi\n\n  printf '[cloud.kubernetes.monitoring.proto.SerialportLog] {\"cluster_hash\":\"%s\",\"vm_instance_name\":\"%s\",\"boot_id\":\"%s\",\"timestamp\":\"%s\",\"bootstrap_status\":{\"step_name\":\"%s\",\"status\":\"%s\",\"status_reason\":\"%s\",\"latency\":%s}}\\n' \\\n  \"${LOG_CLUSTER_ID}\" \"${LOG_INSTANCE_NAME}\" \"${LOG_BOOT_ID}\" \"${timestamp}\" \"${bootstep}\" \"${status}\" \"${status_reason}\" \"${latency}\"\n}\n\n######### Main Function ##########\nlog-init\ndetect_host_info\n\n# Preloader will source this script, and skip the main function. The preloader\n# will choose what to preload by calling install-X functions directly.\n# When configure.sh is sourced by the preload script, $0 and $BASH_SOURCE are\n# different. $BASH_SOURCE still contains the path of configure.sh, while $0 is\n# the path of the preload script.\nif [[ \"$0\" != \"$BASH_SOURCE\" \u0026\u0026 \"${IS_PRELOADER:-\"false\"}\" == \"true\" ]]; then\n  echo \"Running in preloader instead of VM bootsrapping. Skipping installation steps as preloader script will source configure.sh and call corresponding functions.\"\n  return\nfi\n\nlog-start 'ConfigureMain'\necho \"Start to install kubernetes files\"\n\n# if install fails, message-of-the-day (motd) will warn at login shell\nlog-wrap 'SetBrokenMotd' set-broken-motd\n\nKUBE_HOME=\"/home/kubernetes\"\nKUBE_BIN=\"${KUBE_HOME}/bin\"\n\nif [[ \"$(is-master)\" == \"true\" ]]; then\n  log-wrap 'InstallHurl' install-hurl\n  log-wrap 'InstallInplace' install-inplace\nfi\n\n# download and source kube-env\nlog-wrap 'DownloadKubeEnv' download-kube-env\nlog-wrap 'SourceKubeEnv' source \"${KUBE_HOME}/kube-env\"\n\nlog-wrap 'ConfigureCgroupMode' configure-cgroup-mode\n\nlog-wrap 'DownloadKubeletConfig' download-kubelet-config \"${KUBE_HOME}/kubelet-config.yaml\"\n\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'DownloadKubeMasterCerts' download-kube-master-certs-hurl\nfi\n\n# ensure chosen container runtime is present\nlog-wrap 'EnsureContainerRuntime' ensure-container-runtime\n\n# binaries and kube-system manifests\nlog-wrap 'InstallKubeBinaryConfig' install-kube-binary-config\n\nif [[ \"${ENABLE_GCFS:-\"\"}\" == \"true\" ]]; then\n  log-wrap 'InstallRiptide' install-riptide\nfi\n\n# extra node requirements\nlog-wrap 'InstallExtraNodeRequirements' install-extra-node-requirements\n\n# download inplace component manifests\nif [[ \"${KUBERNETES_MASTER:-}\" == \"true\" ]]; then\n  log-wrap 'InplaceRunOnce' retry-forever 30 inplace-run-once\nfi\n\necho \"Done for installing kubernetes files\"\nlog-end 'ConfigureMain'\n",
              "created-by": "projects/352350778257/zones/us-central1-c/instanceGroupManagers/gke-demo-cluster-main-fda3b6c7-grp",
              "disable-legacy-endpoints": "true",
              "gci-metrics-enabled": "true",
              "gci-update-strategy": "update_disabled",
              "google-compute-enable-pcid": "true",
              "instance-template": "projects/352350778257/global/instanceTemplates/gke-demo-cluster-main-fda3b6c7",
              "kube-env": "ALLOCATE_NODE_CIDRS: \"true\"\nAPI_SERVER_TEST_LOG_LEVEL: --v=3\nAUTOSCALER_ENV_VARS: kube_reserved=cpu=60m,memory=435Mi,ephemeral-storage=41Gi;node_labels=cloud.google.com/gke-boot-disk=pd-balanced,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-cpu-scaling-level=1,cloud.google.com/gke-logging-variant=DEFAULT,cloud.google.com/gke-max-pods-per-node=110,cloud.google.com/gke-nodepool=main,cloud.google.com/gke-os-distribution=cos,cloud.google.com/gke-provisioning=standard,cloud.google.com/gke-stack-type=IPV4,cloud.google.com/machine-family=g1,cloud.google.com/private-node=false;arch=amd64;os=linux;os_distribution=cos;evictionHard=memory.available=100Mi,nodefs.available=10%,nodefs.inodesFree=5%,pid.available=10%\nCA_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMRENDQXBTZ0F3SUJBZ0lRRTFCbVEvRG5DZWt5ZGtFbmZFQ0VqekFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlSaE9USTJOalUwWXkwNFpHUTJMVFJsTURJdFlXVTFOQzFsTXpZNFptRTFOVGN5TWpFdwpJQmNOTWpNd05qSTFNakl5TnpRd1doZ1BNakExTXpBMk1UY3lNekkzTkRCYU1DOHhMVEFyQmdOVkJBTVRKR0U1Ck1qWTJOVFJqTFRoa1pEWXROR1V3TWkxaFpUVTBMV1V6TmpobVlUVTFOekl5TVRDQ0FhSXdEUVlKS29aSWh2Y04KQVFFQkJRQURnZ0dQQURDQ0FZb0NnZ0dCQUwyOENPSVYzbjdIcDVGTnRSSGFnbVlMeldDNHFuMGdBRXVIdmZLaQpHVnZDL1piYVhBT0x3YXRCOTczcnllRVBoTDRUOXZSTTc4YklDY3JKUWNzK2MrVmY0NnNHTm9CbjlhSUQ2Qm54CkY0SXRjODA0cE9TUVdOWVdxTkVKU25DMEdBN3RuSWs4S2gzc2ZFMnY5UlRxQlBrbldGbG9ON3ZOdFJ2ZmJlTTEKM3JUYytUQ0lwVWJFdXp5VHVnSjVMWmhkU01VVDBzM2kwbndrL3JnTFNPQzZJcnpqR1kySlUwSDUvNXQxekZxUApMZFBKZ253Mlk0SVMwbktNVVFmdm9lSThmcjZrL1lHNTVGdU9UMzZ5M3FrekROUW13clhaY1JxZXluSHFoOUJhCjVFYXZZVTBCRlFQRkNQdUg3Q2k4dXl3SVhIdEdNekFrTWNIcEg2U1ZEdGlOTnZzVWQyTEpjaXpwcnpobnVOK08KU3RPK2FVRElGMDFLcFE0eGNVcTc0a3Q1QWJMRVZkaHRZZGdGazN2ZzlKU3JINmMyV1BaTVRqaDF6WE5SZHlFTQpodVloQzh6MlJLN04yOUVEUWdmekc2TWFvZ0FWSy9FTE00TTgwRkluMUVPSjNqaVpmNm1NQ2FhNVVIMiswSGkxCnE1SlpvdnF5WlZOYk00akgvMithUnYwdkF3SURBUUFCbzBJd1FEQU9CZ05WSFE4QkFmOEVCQU1DQWdRd0R3WUQKVlIwVEFRSC9CQVV3QXdFQi96QWRCZ05WSFE0RUZnUVVmbWVBZmR4dlBQUVV5K1Y0MlBlNzJ3U1JpWmN3RFFZSgpLb1pJaHZjTkFRRUxCUUFEZ2dHQkFEbWhrUlpOMXRUcXlFd3J5aE9GdG9WMFNLY3dEUXViMVBMZ1A1NzF1dlNGCmQ3Vml1ajgzMW1HanpKNTFKZENGemlmTjk3WFMxTHZhNHpOV1VRMXEraEM1TDVac0NkSjFYRTcyV01JMnNDM1YKMEp5NTFIaWY1ZjU4OFVORzZseTBlN09sakpVd3hOUXVsWWFldFU3STVZbDVoclVXbUgyVldNTUM4bGFaSVBmRApRRlRlZitnVEVjVitWblVnRUtlSWlUQUY1TU9WZFlKOVBGM2NiWjZIb3B0VWxTU3NyQ3VNaGxQRFIvc0o1RlFtCkw5amtRNmw3MzRLQWRLckhudHFwcWN0bDh3QzZMeGtGaC9UWEo2SDdrd05UcjdRelpoZHVmR0I3N2lHNzYzVVkKQkFCY2tvSjQ0cUVhWDRzUTBFYkRyZUJmRVBVc2pQb2F0SnhXSXJkVU12OENNVVV0SDgrZWdGVDU2djZBL0paWgpoTzY3MWVaMU1vWTRFSUFwUno5VC8vNGdkWDlXZmdSd3VPQ0RZNzRGVHYxNTZ2M28wQ084TGp5MmtiRnIyZ29LCjFVV1NwdDYxWmNFelBiYUFJTEgraTV5VlhHZUE5QnhjTDZtVVBya3o0a2VFbCtDNmVGZDhIajRDKzRPbnlUWk8KM0lCSko1T0ZFMUp4SkRmb0hlR3pSUT09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\nCLUSTER_IP_RANGE: 10.0.0.0/14\nCLUSTER_NAME: demo-cluster\nCNI_HASH: ba28765e2939d398dc101ff5543e62a14d132a113102b371af8da86722a4dfbfb3cc5121e6cbdb349e5d9d892e66f034ba24d0b4acd2f1df942c0cd9bcc5723a\nCNI_SHA1: a687a7150d8201ac374b1915829c80ab3cf0c774\nCNI_STORAGE_PATH: https://storage.googleapis.com/gke-release/cni-plugins/v1.0.1-gke.4\nCNI_STORAGE_URL_BASE: https://storage.googleapis.com/gke-release/cni-plugins\nCNI_TAR_PREFIX: cni-plugins-linux-amd64-\nCNI_VERSION: v1.0.1-gke.4\nCONTAINER_RUNTIME: containerd\nCONTAINER_RUNTIME_ENDPOINT: unix:///run/containerd/containerd.sock\nCONTAINER_RUNTIME_NAME: containerd\nCONTAINERD_MAX_CONTAINER_LOG_LINE: \"262144\"\nCREATE_BOOTSTRAP_KUBECONFIG: \"false\"\nDETECT_LOCAL_MODE: NodeCIDR\nDNS_DOMAIN: cluster.local\nDNS_SERVER_IP: 10.3.240.10\nDOCKER_REGISTRY_MIRROR_URL: https://mirror.gcr.io\nELASTICSEARCH_LOGGING_REPLICAS: \"1\"\nENABLE_CLUSTER_DNS: \"true\"\nENABLE_CLUSTER_LOGGING: \"false\"\nENABLE_CLUSTER_MONITORING: none\nENABLE_CLUSTER_REGISTRY: \"false\"\nENABLE_CLUSTER_UI: \"true\"\nENABLE_L7_LOADBALANCING: glbc\nENABLE_LATEST_NPD: \"true\"\nENABLE_METADATA_AGENT: \"\"\nENABLE_METRICS_SERVER: \"true\"\nENABLE_NODE_LOGGING: \"false\"\nENABLE_NODE_PROBLEM_DETECTOR: standalone\nENABLE_NODE_REGISTRATION_CHECKER: \"true\"\nENABLE_NODELOCAL_DNS: \"false\"\nENABLE_SHM_HEALTHCHECK_BINARIES: \"true\"\nENABLE_SYSCTL_TUNING: \"true\"\nENV_TIMESTAMP: \"2023-06-25T23:27:40+00:00\"\nEXEC_AUTH_PLUGIN_HASH: 1e3e03770805fd4f670f51f4f138f2f9af0ffe16c531d6512bcaec02aab98cec7977da5a84ffbc6509e02989db613c1535f0e14af871078b9520a9f2325374b4\nEXEC_AUTH_PLUGIN_LICENSE_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/8e4840462445ac0edd615a1e6175f44efda4908a/LICENSE\nEXEC_AUTH_PLUGIN_SHA1: 96035ca5744c1d4bd797974ac8f3e1ccbf105ea7\nEXEC_AUTH_PLUGIN_URL: https://storage.googleapis.com/gke-prod-binaries/gke-exec-auth-plugin/8e4840462445ac0edd615a1e6175f44efda4908a/linux_amd64/gke-exec-auth-plugin\nEXTRA_DOCKER_OPTS: --insecure-registry 10.0.0.0/8\nEXTRA_POD_SYSCTLS: net.ipv6.conf.all.disable_ipv6=1,net.ipv6.conf.default.disable_ipv6=1\nFEATURE_GATES: DynamicKubeletConfig=false,InTreePluginAWSUnregister=true,InTreePluginAzureDiskUnregister=true,InTreePluginOpenStackUnregister=true,InTreePluginvSphereUnregister=true,DisableKubeletCloudCredentialProviders=false,RotateKubeletServerCertificate=true,ExecProbeTimeout=false,CSIMigrationGCE=true\nFLUENTD_CONTAINER_RUNTIME_SERVICE: containerd\nHEAPSTER_USE_NEW_STACKDRIVER_RESOURCES: \"true\"\nHEAPSTER_USE_OLD_STACKDRIVER_RESOURCES: \"false\"\nHPA_USE_REST_CLIENTS: \"true\"\nINSTANCE_PREFIX: gke-demo-cluster-3f5a8ffb\nKUBE_ADDON_REGISTRY: k8s.gcr.io\nKUBE_CLUSTER_DNS: 10.3.240.10\nKUBE_DOCKER_REGISTRY: gke.gcr.io\nKUBE_MANIFESTS_TAR_HASH: 8a7686b5b245064f4758be7c5c82aec2a8cc4447e2222d7719861196c61efd9d8da76f8f4ce5a5a70c298bc21d645501eec543e8b57618dfd2d18ec74efabb1a\nKUBE_MANIFESTS_TAR_URL: https://storage.googleapis.com/gke-release/kubernetes/release/v1.25.8-gke.1000/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.25.8-gke.1000/kubernetes-manifests.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.25.8-gke.1000/kubernetes-manifests.tar.gz\nKUBE_PROXY_TOKEN: IlaLESxGnsMc58Y4MI2J7ohD63-F0kz515gBMPecI2I=\nKUBELET_ARGS: --v=2 --cloud-provider=external --experimental-mounter-path=/home/kubernetes/containerized_mounter/mounter\n  --cert-dir=/var/lib/kubelet/pki/ --kubeconfig=/var/lib/kubelet/kubeconfig --max-pods=110\n  --volume-plugin-dir=/home/kubernetes/flexvolume --node-status-max-images=25 --container-runtime=remote\n  --container-runtime-endpoint=unix:///run/containerd/containerd.sock --runtime-cgroups=/system.slice/containerd.service\n  --registry-qps=10 --registry-burst=20\nKUBERNETES_MASTER: \"false\"\nKUBERNETES_MASTER_NAME: 10.128.0.5\nLOAD_IMAGE_COMMAND: ctr -n=k8s.io images import\nLOGGING_DESTINATION: \"\"\nLOGGING_STACKDRIVER_RESOURCE_TYPES: \"\"\nMONITORING_FLAG_SET: \"true\"\nNETWORK_PROVIDER: kubenet\nNODE_LOCAL_SSDS_EXT: \"\"\nNON_MASQUERADE_CIDR: 0.0.0.0/0\nREMOUNT_VOLUME_PLUGIN_DIR: \"true\"\nREQUIRE_METADATA_KUBELET_CONFIG_FILE: \"true\"\nSALT_TAR_HASH: \"\"\nSALT_TAR_URL: https://storage.googleapis.com/gke-release/kubernetes/release/v1.25.8-gke.1000/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.25.8-gke.1000/kubernetes-salt.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.25.8-gke.1000/kubernetes-salt.tar.gz\nSERVER_BINARY_TAR_HASH: f8465a47628522468241cf09fc186706392371bf28f5745ec666f0c875e51523b845298418aa2364ef20d8e9f8d0136404c322e7b7b2aa2bcde2ddc79c0d1764\nSERVER_BINARY_TAR_URL: https://storage.googleapis.com/gke-release/kubernetes/release/v1.25.8-gke.1000/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-eu/kubernetes/release/v1.25.8-gke.1000/kubernetes-server-linux-amd64.tar.gz,https://storage.googleapis.com/gke-release-asia/kubernetes/release/v1.25.8-gke.1000/kubernetes-server-linux-amd64.tar.gz\nSERVICE_CLUSTER_IP_RANGE: 10.3.240.0/20\nSTACKDRIVER_ENDPOINT: https://logging.googleapis.com\nSYSCTL_OVERRIDES: \"\"\nTPM_BOOTSTRAP_CERT: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURyRENDQWhTZ0F3SUJBZ0lSQU52OXFHUEd6MWFIaWI2QVQ3R0tONmt3RFFZSktvWklodmNOQVFFTEJRQXcKTHpFdE1Dc0dBMVVFQXhNa1lUa3lOalkxTkdNdE9HUmtOaTAwWlRBeUxXRmxOVFF0WlRNMk9HWmhOVFUzTWpJeApNQjRYRFRJek1EWXlOVEl6TWpVME1Wb1hEVEk0TURZeU16SXpNamMwTVZvd0hERWFNQmdHQTFVRUF4TVJhM1ZpClpXeGxkQzFpYjI5MGMzUnlZWEF3Z2dFaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQkR3QXdnZ0VLQW9JQkFRREMKQ1VzTHFhUVRmbGlBb29aMUFlcE5JcXE5am90OXI1c21kM3dmYURBTzN6NWxNRWxkOG1oMEZUeHVjUkhJZE5tdgpOdk9ON1JTdTVyUExZSk44TkpxRzhaMlQrdGFEeUdTWUNDSG5JR3hpMWd1Q3JsTnJHY2NtTTF1dWVBUkNsZ2NrCnhsd3diT2d4U2ZvTWFvU2RwUVcxMEFnMkdTVTZZRHlibnFOSE1oWXlDb01qdjZ5M3RlZ29jeXdFNjZtMjNadTUKV0xLbU5vYlcyLy95cm9kY292V1I1SGl0M2pNdFlVOG9HcGQ0dnhkVG9wOTdLeWJKc2NmUGppZ3ZGL3VTNHFDMApJeFBZSlBueDJpOXhHMXlhaG1QMmtrSXhuMmtFTlJ1b1ZjYVVxb3IxcjIzWW5TYWZ3dU9sdlA5VlJTNDFCNkdECml6TlU5eThMWWpvN21GUlhyc2RMQWdNQkFBR2pWakJVTUE0R0ExVWREd0VCL3dRRUF3SUZvREFUQmdOVkhTVUUKRERBS0JnZ3JCZ0VGQlFjREFqQU1CZ05WSFJNQkFmOEVBakFBTUI4R0ExVWRJd1FZTUJhQUZINW5nSDNjYnp6MApGTXZsZU5qM3U5c0VrWW1YTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCZ1FCM081cDNqNmkrZnVnanB5VXJrU2FCCkZOY3VTWEkwNG9HRGcrR3hDRVR5Tkg3NDZnT2VQUmZuWWYzN1hlSC9LQTl4cjJlSThTUVNOaTdTazZPVmt0dlQKZjhtQlNMMHd4MXo2bDNqRGgvczl3YWpoQXpHR1NqVVRBbjhPdkxQdEVoQTZGQy9SekdRdUppbm82ZzY4VFZ1aApVZE5Ha0ZKV0tXVjg5dDJhcmFaZEs3bkQ0UllCR2JGVEVGK2Z4cTBsQ0h3NXJmbDZlcGEwa203ajJpNURkWVBtCi9WeThlVk54cTFremV0aWErdEdaM2NMa2hoM281ZEVBWlRWV2RLaDA0allGTmtDY3dEM1hrRWlUaHl6REVmQ0QKVnpDYVEweEw3eFpIZFk2Uys4NzRJT2NqQjh6dWF2bzR0eEhHQnpzejJLVElWUGFZVWtxbGh0V3lJWVB2SU0xYgpEQVIrczRPc3BVaE1YUEJjTytWcmNob0N3K1Vna3o3Yk9sOEluRndJZmhvRmN4K3B0dW5FMnRCS3UwQSswWmJzClFJbVk3cmxGcXlkeVMzdm1teGEyQk1mblU5SlMxUTByUFJ5bklRKzBsWk54dWlFb2x6aDhqck9XN1lEVWR2Vi8KbjM0UUVJUE5lSi83a0FZNzVsVFR3VHdJcDdKdk9QaksweWcvK2NreWdFND0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\nTPM_BOOTSTRAP_KEY: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcEFJQkFBS0NBUUVBd2dsTEM2bWtFMzVZZ0tLR2RRSHFUU0txdlk2TGZhK2JKbmQ4SDJnd0R0OCtaVEJKClhmSm9kQlU4Ym5FUnlIVFpyemJ6amUwVXJ1YXp5MkNUZkRTYWh2R2RrL3JXZzhoa21BZ2g1eUJzWXRZTGdxNVQKYXhuSEpqTmJybmdFUXBZSEpNWmNNR3pvTVVuNkRHcUVuYVVGdGRBSU5oa2xPbUE4bTU2alJ6SVdNZ3FESTcrcwp0N1hvS0hNc0JPdXB0dDJidVZpeXBqYUcxdHYvOHE2SFhLTDFrZVI0cmQ0ekxXRlBLQnFYZUw4WFU2S2ZleXNtCnliSEh6NDRvTHhmN2t1S2d0Q01UMkNUNThkb3ZjUnRjbW9aajlwSkNNWjlwQkRVYnFGWEdsS3FLOWE5dDJKMG0KbjhManBiei9WVVV1TlFlaGc0c3pWUGN2QzJJNk81aFVWNjdIU3dJREFRQUJBb0lCQUNpMmVIZVcvYVZWY2s1egpTNUVMZU5UOGZDVFAzdmJkUE1taWNubklpNlRqTkoxWXQxd3QrN3EzcGZscVloZlVaTVI5M0RhZ1V5R3JxSGY0CjZKazhGRnhTSUFVbnNaRHZJQ1JDT0pMZFc4Q1ZOczhSc3RFYkZJMHdZNEZGRDJmRlFQUjNabXFHdjJWd0p6WXAKdDIrNGEyMU5uQnQxeFRqdGJtb2NyQmZKSzUwTjkrMlE0NTZ1M1lTQy9Qa2RtUHFpa3dPaGRFNzhFYnRmVEV5RgpyRVFGTTdGdllKeDY1bFNJTEc4b1lnMU1LMVdUdHAvQitUUzIrMlVvNHpoNDhOc1hoNmhFVTdjZ3J0MEN4K3ByCmJMZDdVRGo5Z0YrOVM4NjNwTE5UdTZrSi94U3ZNUG5jbGtvY3RVREU5OGY5VGwwY2pxRXIxMmw5NkZwWCsyVk0KRVpSZXBHRUNnWUVBN0FBendJZE5GMTJPbWk3RklWOG1NZW9RcmVCRG5YaHZlcjhDbnlqdC83emduSmhSU2EyRQpGWWxaUDE5MWYvbW05YUovYTd2S2VHRlpkOUZaRDRDTGJycVZLc0RQMnJvZXZpbU5qVk5hcTFEV1lwdmpKeUdqCitjSXB6VUVTTzArRFNweFFFWGhQVk0vaFVuK3VXa2hZZk1OTm5OeHVkSFpPSmpUOXZjU2JzQnNDZ1lFQTBucTIKeG14cnltR2Z0ekxWUkxRUWNnMmFDNmMrSVB6YVFRZkdCOGdtRk5xL2JHTElPcFlhRllqWXZkaC9MV09rOFVuNgo5dTZNb0N0RjV3UzhXTS9hVExHWndFc1BybXlPQk5CckpJSHhqSmdtRTFxVHhqSFBkQ3JjRzZRLzNEL1VwUlpCCnBpcUt0ZUoxSkZycjJDU09BcXNvVmNvdWVqTmUvMGdOVHEvUW1KRUNnWUVBNVJ2QklneDMrOUg0cVpmMENsUzcKMk1NNTFBTWV3UlgxYTcxWmh6Z043VExvL3owajFSb2RXMmNPZkdab3hJZVIzVzhXc25rSnMxb1dxQ3BWZ3FZeApOcHJ1U3lZSjQzYkNkNndSWG56b1RkNVpjanVTQnlBeWR6cFdxSXVlYm5QZnFxUWJXd3BvUVpiYVVPUGhXSVpaCldTMmxBRDVEQU04RlNUUXlqWEw4RGJjQ2dZQTFXNUtXUHNvY3BoNzlMRS9RZU8xcVhIUmUyK2p1Sit1VWJNb1IKRXZaRWR5ZnI3Q2JpWTBiOWlwR1hueGl1Z3dJL2dRZTBMY2xNbVd2Qkl2dzBiNHpod0d3L3lVZVNha2FlaGMrRAprOFdPWk12U1FEWVNHbktDK3BLT0YxZHhHR1ZwN0hoOERYRFlweTRYSjAxK245VzRhM2R3T0M4TUg1WEhsWlo2CkNpd1JZUUtCZ1FDUDRhYUlLZkIvYmNscXI3RnE4ekhuT0ZweVR4Q1IvejVjNlJuM0lvL2N3OG50b0h0VldjWVMKQS95VHZ1VkQ5ZWJQMFBEL2luZUwwNE9BQm5WQ3NiQnpBeVVjYUhBWDhWZjNHaUlmR2l3ekVha1RQQlh5dWZGNgoxbGlFYXl3bU9UNkptdHdQanYyMnZNUmFaUHlRMExhZ2VINklGMm9LMFJQNm8rU0haUFlZWXc9PQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=\nVOLUME_PLUGIN_DIR: /home/kubernetes/flexvolume\nZONE: us-central1-c\n",
              "kube-labels": "cloud.google.com/gke-boot-disk=pd-balanced,cloud.google.com/gke-container-runtime=containerd,cloud.google.com/gke-cpu-scaling-level=1,cloud.google.com/gke-logging-variant=DEFAULT,cloud.google.com/gke-max-pods-per-node=110,cloud.google.com/gke-nodepool=main,cloud.google.com/gke-os-distribution=cos,cloud.google.com/gke-provisioning=standard,cloud.google.com/gke-stack-type=IPV4,cloud.google.com/machine-family=g1,cloud.google.com/private-node=false",
              "kubeconfig": "apiVersion: v1\nkind: Config\nclusters:\n- cluster:\n    server: https://10.128.0.5\n    certificate-authority: '/etc/srv/kubernetes/pki/ca-certificates.crt'\n  name: default-cluster\ncontexts:\n- context:\n    cluster: default-cluster\n    namespace: default\n    user: exec-plugin-auth\n  name: default-context\ncurrent-context: default-context\nusers:\n- name: exec-plugin-auth\n  user:\n    exec:\n      apiVersion: \"client.authentication.k8s.io/v1beta1\"\n      command: '/home/kubernetes/bin/gke-exec-auth-plugin'\n      args: [\"--cache-dir\", '/var/lib/kubelet/pki/']\n",
              "kubelet-config": "apiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: /etc/srv/kubernetes/pki/ca-certificates.crt\nauthorization:\n  mode: Webhook\ncgroupRoot: /\nclusterDNS:\n- 10.3.240.10\nclusterDomain: cluster.local\nenableDebuggingHandlers: true\nevictionHard:\n  memory.available: 100Mi\n  nodefs.available: 10%\n  nodefs.inodesFree: 5%\n  pid.available: 10%\nfeatureGates:\n  CSIMigrationGCE: true\n  DisableKubeletCloudCredentialProviders: false\n  DynamicKubeletConfig: false\n  ExecProbeTimeout: false\n  InTreePluginAWSUnregister: true\n  InTreePluginAzureDiskUnregister: true\n  InTreePluginOpenStackUnregister: true\n  InTreePluginvSphereUnregister: true\n  RotateKubeletServerCertificate: true\nkernelMemcgNotification: true\nkind: KubeletConfiguration\nkubeReserved:\n  cpu: 60m\n  ephemeral-storage: 41Gi\n  memory: 435Mi\nreadOnlyPort: 10255\nserverTLSBootstrap: true\nstaticPodPath: /etc/kubernetes/manifests\n",
              "serial-port-logging-enable": "true",
              "user-data": "#cloud-config\n\nusers:\n  - name: kube-bootstrap-logs-forwarder\n    gecos: User the kube-bootstrap-logs-forwarder.service runs as.\n    system: true\n\nwrite_files:\n  - path: /etc/systemd/system/kube-bootstrap-logs-forwarder.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Forwards Kubernetes bootstrap logs to serial port.\n      Before=kube-node-installation.service\n\n      [Service]\n      User=kube-bootstrap-logs-forwarder\n      Group=systemd-journal\n      SupplementaryGroups=serial\n      ExecStart=journalctl --no-tail --no-pager --follow --utc --output short-iso --unit kube-node-installation --unit kube-node-configuration --unit kubelet\n      StandardOutput=tty\n      TTYPath=/dev/ttyS2\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-installation.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Download and install k8s binaries and configurations\n      After=network-online.target\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/mkdir -p /home/kubernetes/bin\n      ExecStartPre=/bin/mount --bind /home/kubernetes/bin /home/kubernetes/bin\n      ExecStartPre=/bin/mount -o remount,exec /home/kubernetes/bin\n      ExecStartPre=/usr/bin/curl --fail --retry 5 --retry-delay 3 --silent --show-error -H \"X-Google-Metadata-Request: True\" -o /home/kubernetes/bin/configure.sh http://metadata.google.internal/computeMetadata/v1/instance/attributes/configure-sh\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure.sh\n      ExecStart=/home/kubernetes/bin/configure.sh\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-node-configuration.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Configure kubernetes node\n      After=kube-node-installation.service\n\n      [Service]\n      Type=oneshot\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/configure-helper.sh\n      ExecStart=/home/kubernetes/bin/configure-helper.sh\n      ExecStartPost=systemctl stop kube-bootstrap-logs-forwarder.service\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-container-runtime-monitor.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for container runtime\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh container-runtime\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubelet-monitor.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes health monitoring for kubelet\n      After=kube-node-configuration.service\n\n      [Service]\n      Restart=always\n      RestartSec=10\n      RemainAfterExit=yes\n      RemainAfterExit=yes\n      ExecStartPre=/bin/chmod 544 /home/kubernetes/bin/health-monitor.sh\n      ExecStart=/home/kubernetes/bin/health-monitor.sh kubelet\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.timer\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Hourly kube-logrotate invocation\n\n      [Timer]\n      OnCalendar=hourly\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kube-logrotate.service\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes log rotation\n      After=kube-node-configuration.service\n\n      [Service]\n      Type=oneshot\n      ExecStart=-/usr/sbin/logrotate /etc/logrotate.conf\n\n      [Install]\n      WantedBy=kubernetes.target\n\n  - path: /etc/systemd/system/kubernetes.target\n    permissions: '0644'\n    owner: root\n    content: |\n      [Unit]\n      Description=Kubernetes\n\n      [Install]\n      WantedBy=multi-user.target\n\n  - path: /etc/modprobe.d/sunrpc.conf\n    permissions: '0644'\n    owner: root\n    # The GKE metadata server uses ports 987-989, so the sunrpc range should be restricted to be below.\n    content: |\n      options sunrpc max_resvport=986\n\nruncmd:\n - systemctl daemon-reload\n - systemctl enable kube-bootstrap-logs-forwarder.service\n - systemctl enable kube-node-installation.service\n - systemctl enable kube-node-configuration.service\n - systemctl enable kube-container-runtime-monitor.service\n - systemctl enable kubelet-monitor.service\n - systemctl enable kube-logrotate.timer\n - systemctl enable kube-logrotate.service\n - systemctl enable kubernetes.target\n - systemctl start kubernetes.target\n"
            },
            "metadata_fingerprint": "1buaaHWL3_0=",
            "metadata_startup_script": null,
            "min_cpu_platform": "",
            "name": "gke-demo-cluster-main-fda3b6c7-37gd",
            "network_interface": [
              {
                "access_config": [
                  {
                    "nat_ip": "34.133.32.21",
                    "network_tier": "PREMIUM",
                    "public_ptr_domain_name": ""
                  }
                ],
                "alias_ip_range": [],
                "ipv6_access_config": [],
                "ipv6_access_type": "",
                "name": "nic0",
                "network": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/global/networks/default",
                "network_ip": "10.128.0.7",
                "nic_type": "",
                "queue_count": 0,
                "stack_type": "IPV4_ONLY",
                "subnetwork": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/regions/us-central1/subnetworks/default",
                "subnetwork_project": "k8s-k3s-386218"
              }
            ],
            "network_performance_config": null,
            "project": "k8s-k3s-386218",
            "reservation_affinity": null,
            "resource_policies": null,
            "scheduling": [
              {
                "automatic_restart": true,
                "instance_termination_action": "",
                "min_node_cpus": 0,
                "node_affinities": [],
                "on_host_maintenance": "MIGRATE",
                "preemptible": false,
                "provisioning_model": "STANDARD"
              }
            ],
            "scratch_disk": [],
            "self_link": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instances/gke-demo-cluster-main-fda3b6c7-37gd",
            "service_account": [
              {
                "email": "352350778257-compute@developer.gserviceaccount.com",
                "scopes": [
                  "https://www.googleapis.com/auth/devstorage.read_only",
                  "https://www.googleapis.com/auth/logging.write",
                  "https://www.googleapis.com/auth/monitoring",
                  "https://www.googleapis.com/auth/service.management.readonly",
                  "https://www.googleapis.com/auth/servicecontrol",
                  "https://www.googleapis.com/auth/trace.append"
                ]
              }
            ],
            "shielded_instance_config": [
              {
                "enable_integrity_monitoring": true,
                "enable_secure_boot": false,
                "enable_vtpm": true
              }
            ],
            "tags": [
              "gke-demo-cluster-3f5a8ffb-node"
            ],
            "tags_fingerprint": "J1cGOA2A7iw=",
            "zone": "us-central1-c"
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "mode": "data",
      "type": "google_compute_instance_group",
      "name": "node_instance_groups",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 0,
          "attributes": {
            "description": "This instance group is controlled by Instance Group Manager 'gke-demo-cluster-main-fda3b6c7-grp'. To modify instances in this group, use the Instance Group Manager API: https://cloud.google.com/compute/docs/reference/latest/instanceGroupManagers",
            "id": "projects/k8s-k3s-386218/zones/us-central1-c/instanceGroups/gke-demo-cluster-main-fda3b6c7-grp",
            "instances": [
              "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instances/gke-demo-cluster-main-fda3b6c7-2xkm",
              "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instances/gke-demo-cluster-main-fda3b6c7-37gd"
            ],
            "name": "gke-demo-cluster-main-fda3b6c7-grp",
            "named_port": [],
            "network": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/global/networks/default",
            "project": "k8s-k3s-386218",
            "self_link": "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instanceGroups/gke-demo-cluster-main-fda3b6c7-grp",
            "size": 2,
            "zone": "us-central1-c"
          },
          "sensitive_attributes": []
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_container_cluster",
      "name": "demo",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "addons_config": [
              {
                "cloudrun_config": [],
                "config_connector_config": [],
                "dns_cache_config": [],
                "gce_persistent_disk_csi_driver_config": [
                  {
                    "enabled": true
                  }
                ],
                "gcp_filestore_csi_driver_config": [],
                "gke_backup_agent_config": [],
                "horizontal_pod_autoscaling": [],
                "http_load_balancing": [],
                "network_policy_config": [
                  {
                    "disabled": true
                  }
                ]
              }
            ],
            "authenticator_groups_config": [],
            "binary_authorization": [
              {
                "enabled": false,
                "evaluation_mode": ""
              }
            ],
            "cluster_autoscaling": [
              {
                "auto_provisioning_defaults": [],
                "enabled": false,
                "resource_limits": []
              }
            ],
            "cluster_ipv4_cidr": "10.0.0.0/14",
            "confidential_nodes": [],
            "cost_management_config": [],
            "database_encryption": [
              {
                "key_name": "",
                "state": "DECRYPTED"
              }
            ],
            "datapath_provider": "",
            "default_max_pods_per_node": null,
            "default_snat_status": [
              {
                "disabled": false
              }
            ],
            "description": "",
            "dns_config": [],
            "enable_autopilot": false,
            "enable_binary_authorization": false,
            "enable_intranode_visibility": false,
            "enable_kubernetes_alpha": false,
            "enable_l4_ilb_subsetting": false,
            "enable_legacy_abac": false,
            "enable_shielded_nodes": true,
            "enable_tpu": false,
            "endpoint": "104.198.177.143",
            "gateway_api_config": [],
            "id": "projects/k8s-k3s-386218/locations/us-central1-c/clusters/demo-cluster",
            "initial_node_count": 1,
            "ip_allocation_policy": [],
            "label_fingerprint": "a9dc16a7",
            "location": "us-central1-c",
            "logging_config": [
              {
                "enable_components": [
                  "SYSTEM_COMPONENTS",
                  "WORKLOADS"
                ]
              }
            ],
            "logging_service": "logging.googleapis.com/kubernetes",
            "maintenance_policy": [],
            "master_auth": [
              {
                "client_certificate": "",
                "client_certificate_config": [
                  {
                    "issue_client_certificate": false
                  }
                ],
                "client_key": "",
                "cluster_ca_certificate": "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVMRENDQXBTZ0F3SUJBZ0lRRTFCbVEvRG5DZWt5ZGtFbmZFQ0VqekFOQmdrcWhraUc5dzBCQVFzRkFEQXYKTVMwd0t3WURWUVFERXlSaE9USTJOalUwWXkwNFpHUTJMVFJsTURJdFlXVTFOQzFsTXpZNFptRTFOVGN5TWpFdwpJQmNOTWpNd05qSTFNakl5TnpRd1doZ1BNakExTXpBMk1UY3lNekkzTkRCYU1DOHhMVEFyQmdOVkJBTVRKR0U1Ck1qWTJOVFJqTFRoa1pEWXROR1V3TWkxaFpUVTBMV1V6TmpobVlUVTFOekl5TVRDQ0FhSXdEUVlKS29aSWh2Y04KQVFFQkJRQURnZ0dQQURDQ0FZb0NnZ0dCQUwyOENPSVYzbjdIcDVGTnRSSGFnbVlMeldDNHFuMGdBRXVIdmZLaQpHVnZDL1piYVhBT0x3YXRCOTczcnllRVBoTDRUOXZSTTc4YklDY3JKUWNzK2MrVmY0NnNHTm9CbjlhSUQ2Qm54CkY0SXRjODA0cE9TUVdOWVdxTkVKU25DMEdBN3RuSWs4S2gzc2ZFMnY5UlRxQlBrbldGbG9ON3ZOdFJ2ZmJlTTEKM3JUYytUQ0lwVWJFdXp5VHVnSjVMWmhkU01VVDBzM2kwbndrL3JnTFNPQzZJcnpqR1kySlUwSDUvNXQxekZxUApMZFBKZ253Mlk0SVMwbktNVVFmdm9lSThmcjZrL1lHNTVGdU9UMzZ5M3FrekROUW13clhaY1JxZXluSHFoOUJhCjVFYXZZVTBCRlFQRkNQdUg3Q2k4dXl3SVhIdEdNekFrTWNIcEg2U1ZEdGlOTnZzVWQyTEpjaXpwcnpobnVOK08KU3RPK2FVRElGMDFLcFE0eGNVcTc0a3Q1QWJMRVZkaHRZZGdGazN2ZzlKU3JINmMyV1BaTVRqaDF6WE5SZHlFTQpodVloQzh6MlJLN04yOUVEUWdmekc2TWFvZ0FWSy9FTE00TTgwRkluMUVPSjNqaVpmNm1NQ2FhNVVIMiswSGkxCnE1SlpvdnF5WlZOYk00akgvMithUnYwdkF3SURBUUFCbzBJd1FEQU9CZ05WSFE4QkFmOEVCQU1DQWdRd0R3WUQKVlIwVEFRSC9CQVV3QXdFQi96QWRCZ05WSFE0RUZnUVVmbWVBZmR4dlBQUVV5K1Y0MlBlNzJ3U1JpWmN3RFFZSgpLb1pJaHZjTkFRRUxCUUFEZ2dHQkFEbWhrUlpOMXRUcXlFd3J5aE9GdG9WMFNLY3dEUXViMVBMZ1A1NzF1dlNGCmQ3Vml1ajgzMW1HanpKNTFKZENGemlmTjk3WFMxTHZhNHpOV1VRMXEraEM1TDVac0NkSjFYRTcyV01JMnNDM1YKMEp5NTFIaWY1ZjU4OFVORzZseTBlN09sakpVd3hOUXVsWWFldFU3STVZbDVoclVXbUgyVldNTUM4bGFaSVBmRApRRlRlZitnVEVjVitWblVnRUtlSWlUQUY1TU9WZFlKOVBGM2NiWjZIb3B0VWxTU3NyQ3VNaGxQRFIvc0o1RlFtCkw5amtRNmw3MzRLQWRLckhudHFwcWN0bDh3QzZMeGtGaC9UWEo2SDdrd05UcjdRelpoZHVmR0I3N2lHNzYzVVkKQkFCY2tvSjQ0cUVhWDRzUTBFYkRyZUJmRVBVc2pQb2F0SnhXSXJkVU12OENNVVV0SDgrZWdGVDU2djZBL0paWgpoTzY3MWVaMU1vWTRFSUFwUno5VC8vNGdkWDlXZmdSd3VPQ0RZNzRGVHYxNTZ2M28wQ084TGp5MmtiRnIyZ29LCjFVV1NwdDYxWmNFelBiYUFJTEgraTV5VlhHZUE5QnhjTDZtVVBya3o0a2VFbCtDNmVGZDhIajRDKzRPbnlUWk8KM0lCSko1T0ZFMUp4SkRmb0hlR3pSUT09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K"
              }
            ],
            "master_authorized_networks_config": [],
            "master_version": "1.25.8-gke.1000",
            "mesh_certificates": [],
            "min_master_version": null,
            "monitoring_config": [
              {
                "enable_components": [
                  "SYSTEM_COMPONENTS"
                ],
                "managed_prometheus": []
              }
            ],
            "monitoring_service": "monitoring.googleapis.com/kubernetes",
            "name": "demo-cluster",
            "network": "projects/k8s-k3s-386218/global/networks/default",
            "network_policy": [
              {
                "enabled": false,
                "provider": "PROVIDER_UNSPECIFIED"
              }
            ],
            "networking_mode": "ROUTES",
            "node_config": [
              {
                "advanced_machine_features": [],
                "boot_disk_kms_key": "",
                "disk_size_gb": 100,
                "disk_type": "pd-balanced",
                "ephemeral_storage_local_ssd_config": [],
                "gcfs_config": [],
                "guest_accelerator": [],
                "gvnic": [],
                "image_type": "COS_CONTAINERD",
                "kubelet_config": [],
                "labels": {},
                "linux_node_config": [],
                "local_nvme_ssd_block_config": [],
                "local_ssd_count": 0,
                "logging_variant": "DEFAULT",
                "machine_type": "g1-small",
                "metadata": {
                  "disable-legacy-endpoints": "true"
                },
                "min_cpu_platform": "",
                "node_group": "",
                "oauth_scopes": [
                  "https://www.googleapis.com/auth/devstorage.read_only",
                  "https://www.googleapis.com/auth/logging.write",
                  "https://www.googleapis.com/auth/monitoring",
                  "https://www.googleapis.com/auth/service.management.readonly",
                  "https://www.googleapis.com/auth/servicecontrol",
                  "https://www.googleapis.com/auth/trace.append"
                ],
                "preemptible": false,
                "reservation_affinity": [],
                "resource_labels": {},
                "service_account": "default",
                "shielded_instance_config": [
                  {
                    "enable_integrity_monitoring": true,
                    "enable_secure_boot": false
                  }
                ],
                "sole_tenant_config": [],
                "spot": false,
                "tags": [],
                "taint": [],
                "workload_metadata_config": []
              }
            ],
            "node_locations": [],
            "node_pool": [
              {
                "autoscaling": [],
                "initial_node_count": 2,
                "instance_group_urls": [
                  "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instanceGroupManagers/gke-demo-cluster-main-fda3b6c7-grp"
                ],
                "managed_instance_group_urls": [
                  "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instanceGroups/gke-demo-cluster-main-fda3b6c7-grp"
                ],
                "management": [
                  {
                    "auto_repair": true,
                    "auto_upgrade": true
                  }
                ],
                "max_pods_per_node": 0,
                "name": "main",
                "name_prefix": "",
                "network_config": [
                  {
                    "create_pod_range": false,
                    "enable_private_nodes": false,
                    "pod_cidr_overprovision_config": [],
                    "pod_ipv4_cidr_block": "",
                    "pod_range": ""
                  }
                ],
                "node_config": [
                  {
                    "advanced_machine_features": [],
                    "boot_disk_kms_key": "",
                    "disk_size_gb": 100,
                    "disk_type": "pd-balanced",
                    "ephemeral_storage_local_ssd_config": [],
                    "gcfs_config": [],
                    "guest_accelerator": [],
                    "gvnic": [],
                    "image_type": "COS_CONTAINERD",
                    "kubelet_config": [],
                    "labels": {},
                    "linux_node_config": [],
                    "local_nvme_ssd_block_config": [],
                    "local_ssd_count": 0,
                    "logging_variant": "DEFAULT",
                    "machine_type": "g1-small",
                    "metadata": {
                      "disable-legacy-endpoints": "true"
                    },
                    "min_cpu_platform": "",
                    "node_group": "",
                    "oauth_scopes": [
                      "https://www.googleapis.com/auth/devstorage.read_only",
                      "https://www.googleapis.com/auth/logging.write",
                      "https://www.googleapis.com/auth/monitoring",
                      "https://www.googleapis.com/auth/service.management.readonly",
                      "https://www.googleapis.com/auth/servicecontrol",
                      "https://www.googleapis.com/auth/trace.append"
                    ],
                    "preemptible": false,
                    "reservation_affinity": [],
                    "resource_labels": {},
                    "service_account": "default",
                    "shielded_instance_config": [
                      {
                        "enable_integrity_monitoring": true,
                        "enable_secure_boot": false
                      }
                    ],
                    "sole_tenant_config": [],
                    "spot": false,
                    "tags": [],
                    "taint": [],
                    "workload_metadata_config": []
                  }
                ],
                "node_count": 2,
                "node_locations": [
                  "us-central1-c"
                ],
                "placement_policy": [],
                "upgrade_settings": [
                  {
                    "blue_green_settings": [],
                    "max_surge": 1,
                    "max_unavailable": 0,
                    "strategy": "SURGE"
                  }
                ],
                "version": "1.25.8-gke.1000"
              }
            ],
            "node_pool_defaults": [
              {
                "node_config_defaults": [
                  {
                    "logging_variant": "DEFAULT"
                  }
                ]
              }
            ],
            "node_version": "1.25.8-gke.1000",
            "notification_config": [
              {
                "pubsub": [
                  {
                    "enabled": false,
                    "filter": [],
                    "topic": ""
                  }
                ]
              }
            ],
            "operation": null,
            "private_cluster_config": [
              {
                "enable_private_endpoint": false,
                "enable_private_nodes": false,
                "master_global_access_config": [
                  {
                    "enabled": false
                  }
                ],
                "master_ipv4_cidr_block": "",
                "peering_name": "",
                "private_endpoint": "10.128.0.5",
                "private_endpoint_subnetwork": "",
                "public_endpoint": "104.198.177.143"
              }
            ],
            "private_ipv6_google_access": "",
            "project": "k8s-k3s-386218",
            "release_channel": [
              {
                "channel": "REGULAR"
              }
            ],
            "remove_default_node_pool": true,
            "resource_labels": {},
            "resource_usage_export_config": [],
            "self_link": "https://container.googleapis.com/v1/projects/k8s-k3s-386218/zones/us-central1-c/clusters/demo-cluster",
            "service_external_ips_config": [
              {
                "enabled": false
              }
            ],
            "services_ipv4_cidr": "10.3.240.0/20",
            "subnetwork": "projects/k8s-k3s-386218/regions/us-central1/subnetworks/default",
            "timeouts": null,
            "tpu_ipv4_cidr_block": "",
            "vertical_pod_autoscaling": [],
            "workload_identity_config": []
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoyNDAwMDAwMDAwMDAwLCJkZWxldGUiOjI0MDAwMDAwMDAwMDAsInJlYWQiOjI0MDAwMDAwMDAwMDAsInVwZGF0ZSI6MzYwMDAwMDAwMDAwMH0sInNjaGVtYV92ZXJzaW9uIjoiMSJ9"
        }
      ]
    },
    {
      "mode": "managed",
      "type": "google_container_node_pool",
      "name": "main",
      "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "autoscaling": [],
            "cluster": "demo-cluster",
            "id": "projects/k8s-k3s-386218/locations/us-central1-c/clusters/demo-cluster/nodePools/main",
            "initial_node_count": 2,
            "instance_group_urls": [
              "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instanceGroupManagers/gke-demo-cluster-main-fda3b6c7-grp"
            ],
            "location": "us-central1-c",
            "managed_instance_group_urls": [
              "https://www.googleapis.com/compute/v1/projects/k8s-k3s-386218/zones/us-central1-c/instanceGroups/gke-demo-cluster-main-fda3b6c7-grp"
            ],
            "management": [
              {
                "auto_repair": true,
                "auto_upgrade": true
              }
            ],
            "max_pods_per_node": null,
            "name": "main",
            "name_prefix": "",
            "network_config": [
              {
                "create_pod_range": false,
                "enable_private_nodes": false,
                "pod_cidr_overprovision_config": [],
                "pod_ipv4_cidr_block": "",
                "pod_range": ""
              }
            ],
            "node_config": [
              {
                "advanced_machine_features": [],
                "boot_disk_kms_key": "",
                "disk_size_gb": 100,
                "disk_type": "pd-balanced",
                "ephemeral_storage_local_ssd_config": [],
                "gcfs_config": [],
                "guest_accelerator": [],
                "gvnic": [],
                "image_type": "COS_CONTAINERD",
                "kubelet_config": [],
                "labels": {},
                "linux_node_config": [],
                "local_nvme_ssd_block_config": [],
                "local_ssd_count": 0,
                "logging_variant": "DEFAULT",
                "machine_type": "g1-small",
                "metadata": {
                  "disable-legacy-endpoints": "true"
                },
                "min_cpu_platform": "",
                "node_group": "",
                "oauth_scopes": [
                  "https://www.googleapis.com/auth/devstorage.read_only",
                  "https://www.googleapis.com/auth/logging.write",
                  "https://www.googleapis.com/auth/monitoring",
                  "https://www.googleapis.com/auth/service.management.readonly",
                  "https://www.googleapis.com/auth/servicecontrol",
                  "https://www.googleapis.com/auth/trace.append"
                ],
                "preemptible": false,
                "reservation_affinity": [],
                "resource_labels": {},
                "service_account": "default",
                "shielded_instance_config": [
                  {
                    "enable_integrity_monitoring": true,
                    "enable_secure_boot": false
                  }
                ],
                "sole_tenant_config": [],
                "spot": false,
                "tags": [],
                "taint": [],
                "workload_metadata_config": []
              }
            ],
            "node_count": 2,
            "node_locations": [
              "us-central1-c"
            ],
            "operation": null,
            "placement_policy": [],
            "project": "k8s-k3s-386218",
            "timeouts": null,
            "upgrade_settings": [
              {
                "blue_green_settings": [],
                "max_surge": 1,
                "max_unavailable": 0,
                "strategy": "SURGE"
              }
            ],
            "version": "1.25.8-gke.1000"
          },
          "sensitive_attributes": [],
          "private": "eyJlMmJmYjczMC1lY2FhLTExZTYtOGY4OC0zNDM2M2JjN2M0YzAiOnsiY3JlYXRlIjoxODAwMDAwMDAwMDAwLCJkZWxldGUiOjE4MDAwMDAwMDAwMDAsInVwZGF0ZSI6MTgwMDAwMDAwMDAwMH0sInNjaGVtYV92ZXJzaW9uIjoiMSJ9",
          "dependencies": [
            "google_container_cluster.demo"
          ]
        }
      ]
    }
  ],
  "check_results": null
}
